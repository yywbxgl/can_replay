/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-2019 Erik Moqvist
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * This file was generated by cantools version 40.0.0 Tue Dec 31 09:56:46 2024.
 */

#ifndef EV6_H
#define EV6_H

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

#ifndef EINVAL
#    define EINVAL 22
#endif

/* Frame ids. */
#define EV6_TBOX_3_E3H_FRAME_ID (0x00u)
#define EV6_TBOX_2_F_BH_FRAME_ID (0x2fbu)
#define EV6_PEPS_211H_FRAME_ID (0x211u)
#define EV6_ADAS_RAD_140H_FRAME_ID (0x140u)
#define EV6_ADAS_CAM_10_AH_FRAME_ID (0x10au)
#define EV6_MCU_97H_FRAME_ID (0x97u)
#define EV6_ESP_125H_FRAME_ID (0x125u)
#define EV6_VCU_119H_FRAME_ID (0x119u)
#define EV6_BCM_105H_FRAME_ID (0x105u)
#define EV6_ACU_021H_FRAME_ID (0x21u)
#define EV6_VCU_123H_FRAME_ID (0x123u)
#define EV6_IBOOSTER_13_CH_FRAME_ID (0x13cu)
#define EV6_IBOOSTER_13_AH_FRAME_ID (0x13au)
#define EV6_ADAS_RAD_118H_FRAME_ID (0x118u)
#define EV6_APA_92H_FRAME_ID (0x92u)
#define EV6_APA_91H_FRAME_ID (0x91u)
#define EV6_IHU_2_F_CH_FRAME_ID (0x2fcu)
#define EV6_APA_264H_FRAME_ID (0x264u)
#define EV6_VCU_200H_FRAME_ID (0x200u)
#define EV6_EPS_131H_FRAME_ID (0x131u)
#define EV6_EPS_117H_FRAME_ID (0x117u)
#define EV6_ESP_109H_FRAME_ID (0x109u)
#define EV6_ADAS_CAM_107H_FRAME_ID (0x107u)
#define EV6_ESP_104H_FRAME_ID (0x104u)
#define EV6_ESP_102H_FRAME_ID (0x102u)
#define EV6_ESP_101H_FRAME_ID (0x101u)

/* Frame lengths in bytes. */
#define EV6_TBOX_3_E3H_LENGTH (8u)
#define EV6_TBOX_2_F_BH_LENGTH (8u)
#define EV6_PEPS_211H_LENGTH (8u)
#define EV6_ADAS_RAD_140H_LENGTH (8u)
#define EV6_ADAS_CAM_10_AH_LENGTH (8u)
#define EV6_MCU_97H_LENGTH (8u)
#define EV6_ESP_125H_LENGTH (8u)
#define EV6_VCU_119H_LENGTH (8u)
#define EV6_BCM_105H_LENGTH (8u)
#define EV6_ACU_021H_LENGTH (8u)
#define EV6_VCU_123H_LENGTH (8u)
#define EV6_IBOOSTER_13_CH_LENGTH (8u)
#define EV6_IBOOSTER_13_AH_LENGTH (8u)
#define EV6_ADAS_RAD_118H_LENGTH (8u)
#define EV6_APA_92H_LENGTH (8u)
#define EV6_APA_91H_LENGTH (8u)
#define EV6_IHU_2_F_CH_LENGTH (8u)
#define EV6_APA_264H_LENGTH (8u)
#define EV6_VCU_200H_LENGTH (8u)
#define EV6_EPS_131H_LENGTH (8u)
#define EV6_EPS_117H_LENGTH (8u)
#define EV6_ESP_109H_LENGTH (8u)
#define EV6_ADAS_CAM_107H_LENGTH (8u)
#define EV6_ESP_104H_LENGTH (8u)
#define EV6_ESP_102H_LENGTH (8u)
#define EV6_ESP_101H_LENGTH (8u)

/* Extended or standard frame types. */
#define EV6_TBOX_3_E3H_IS_EXTENDED (0)
#define EV6_TBOX_2_F_BH_IS_EXTENDED (0)
#define EV6_PEPS_211H_IS_EXTENDED (0)
#define EV6_ADAS_RAD_140H_IS_EXTENDED (0)
#define EV6_ADAS_CAM_10_AH_IS_EXTENDED (0)
#define EV6_MCU_97H_IS_EXTENDED (0)
#define EV6_ESP_125H_IS_EXTENDED (0)
#define EV6_VCU_119H_IS_EXTENDED (0)
#define EV6_BCM_105H_IS_EXTENDED (0)
#define EV6_ACU_021H_IS_EXTENDED (0)
#define EV6_VCU_123H_IS_EXTENDED (0)
#define EV6_IBOOSTER_13_CH_IS_EXTENDED (0)
#define EV6_IBOOSTER_13_AH_IS_EXTENDED (0)
#define EV6_ADAS_RAD_118H_IS_EXTENDED (0)
#define EV6_APA_92H_IS_EXTENDED (0)
#define EV6_APA_91H_IS_EXTENDED (0)
#define EV6_IHU_2_F_CH_IS_EXTENDED (0)
#define EV6_APA_264H_IS_EXTENDED (0)
#define EV6_VCU_200H_IS_EXTENDED (0)
#define EV6_EPS_131H_IS_EXTENDED (0)
#define EV6_EPS_117H_IS_EXTENDED (0)
#define EV6_ESP_109H_IS_EXTENDED (0)
#define EV6_ADAS_CAM_107H_IS_EXTENDED (0)
#define EV6_ESP_104H_IS_EXTENDED (0)
#define EV6_ESP_102H_IS_EXTENDED (0)
#define EV6_ESP_101H_IS_EXTENDED (0)

/* Frame cycle times in milliseconds. */
#define EV6_TBOX_2_F_BH_CYCLE_TIME_MS (100u)
#define EV6_PEPS_211H_CYCLE_TIME_MS (100u)
#define EV6_ADAS_RAD_140H_CYCLE_TIME_MS (50u)
#define EV6_ADAS_CAM_10_AH_CYCLE_TIME_MS (50u)
#define EV6_MCU_97H_CYCLE_TIME_MS (20u)
#define EV6_ESP_125H_CYCLE_TIME_MS (20u)
#define EV6_VCU_119H_CYCLE_TIME_MS (20u)
#define EV6_BCM_105H_CYCLE_TIME_MS (50u)
#define EV6_ACU_021H_CYCLE_TIME_MS (100u)
#define EV6_VCU_123H_CYCLE_TIME_MS (20u)
#define EV6_IBOOSTER_13_CH_CYCLE_TIME_MS (20u)
#define EV6_IBOOSTER_13_AH_CYCLE_TIME_MS (20u)
#define EV6_ADAS_RAD_118H_CYCLE_TIME_MS (20u)
#define EV6_APA_92H_CYCLE_TIME_MS (20u)
#define EV6_APA_91H_CYCLE_TIME_MS (20u)
#define EV6_IHU_2_F_CH_CYCLE_TIME_MS (100u)
#define EV6_APA_264H_CYCLE_TIME_MS (100u)
#define EV6_VCU_200H_CYCLE_TIME_MS (100u)
#define EV6_EPS_131H_CYCLE_TIME_MS (20u)
#define EV6_EPS_117H_CYCLE_TIME_MS (20u)
#define EV6_ESP_109H_CYCLE_TIME_MS (20u)
#define EV6_ADAS_CAM_107H_CYCLE_TIME_MS (20u)
#define EV6_ESP_104H_CYCLE_TIME_MS (20u)
#define EV6_ESP_102H_CYCLE_TIME_MS (20u)
#define EV6_ESP_101H_CYCLE_TIME_MS (20u)

/* Signal choices. */
#define EV6_TBOX_2_F_BH_TBOX_TSR_SW_STS_INVALID_VALUE_CHOICE (0u)
#define EV6_TBOX_2_F_BH_TBOX_TSR_SW_STS_CLOSE_CHOICE (1u)
#define EV6_TBOX_2_F_BH_TBOX_TSR_SW_STS_OPEN_CHOICE (2u)
#define EV6_TBOX_2_F_BH_TBOX_TSR_SW_STS_ERROR_CHOICE (3u)

#define EV6_TBOX_2_F_BH_TBOX_INTELLIGENT_HIGH_BEAM_SW_STS_OFF_CHOICE (0u)
#define EV6_TBOX_2_F_BH_TBOX_INTELLIGENT_HIGH_BEAM_SW_STS_ON_CHOICE (1u)
#define EV6_TBOX_2_F_BH_TBOX_INTELLIGENT_HIGH_BEAM_SW_STS_ERR_CHOICE (2u)

#define EV6_TBOX_2_F_BH_TBOX_LKA_SWITCH_STATUS_INVALID_VALUE_CHOICE (0u)
#define EV6_TBOX_2_F_BH_TBOX_LKA_SWITCH_STATUS_CLOSE_CHOICE (1u)
#define EV6_TBOX_2_F_BH_TBOX_LKA_SWITCH_STATUS_OPEN_CHOICE (2u)
#define EV6_TBOX_2_F_BH_TBOX_LKA_SWITCH_STATUS_ERROR_CHOICE (3u)

#define EV6_TBOX_2_F_BH_TBOX_LDW_SWITCH_STATUS_INVALID_VALUE_CHOICE (0u)
#define EV6_TBOX_2_F_BH_TBOX_LDW_SWITCH_STATUS_CLOSE_CHOICE (1u)
#define EV6_TBOX_2_F_BH_TBOX_LDW_SWITCH_STATUS_OPEN___CHOICE (2u)
#define EV6_TBOX_2_F_BH_TBOX_LDW_SWITCH_STATUS_ERROR_CHOICE (3u)

#define EV6_TBOX_2_F_BH_TBOX_FCWAEB_SWITCH_STATUS_OFF_CHOICE (0u)
#define EV6_TBOX_2_F_BH_TBOX_FCWAEB_SWITCH_STATUS_ON_CHOICE (1u)

#define EV6_TBOX_2_F_BH_TBOX_BSD_SWITCH_STATUS_INVALID_VALUE_CHOICE (0u)
#define EV6_TBOX_2_F_BH_TBOX_BSD_SWITCH_STATUS_CLOSE_CHOICE (1u)
#define EV6_TBOX_2_F_BH_TBOX_BSD_SWITCH_STATUS_OPEN_CHOICE (2u)
#define EV6_TBOX_2_F_BH_TBOX_BSD_SWITCH_STATUS_ERROR_CHOICE (3u)

#define EV6_PEPS_211H_POWER_MODE_PEPS_OFF_CHOICE (0u)
#define EV6_PEPS_211H_POWER_MODE_PEPS_ON_CHOICE (1u)
#define EV6_PEPS_211H_POWER_MODE_PEPS_CRANK_PENDING___RESERVE__CHOICE (2u)
#define EV6_PEPS_211H_POWER_MODE_PEPS_START_CHOICE (3u)
#define EV6_PEPS_211H_POWER_MODE_PEPS_CRANK_OFF___RESERVE__CHOICE (4u)

#define EV6_ADAS_RAD_140H_ACC_TAKE_OVER_REQ_NO__TAKEOVER_REQUEST__CHOICE (0u)
#define EV6_ADAS_RAD_140H_ACC_TAKE_OVER_REQ_VALID__TAKEOVER_REQUEST__CHOICE (1u)

#define EV6_ADAS_RAD_140H_ACC_MOD_STS_OFF_MODE__CHOICE (0u)
#define EV6_ADAS_RAD_140H_ACC_MOD_STS_PASSIVE_MODE__REJECT___CHOICE (1u)
#define EV6_ADAS_RAD_140H_ACC_MOD_STS_PASSIVE_MODE__STAND_BY___CHOICE (2u)
#define EV6_ADAS_RAD_140H_ACC_MOD_STS_ACTIVE__CONTROL_MODE_CHOICE (3u)
#define EV6_ADAS_RAD_140H_ACC_MOD_STS_BRAKE_ONLY_MODE_CHOICE (4u)
#define EV6_ADAS_RAD_140H_ACC_MOD_STS_OVERRIDE_CHOICE (5u)
#define EV6_ADAS_RAD_140H_ACC_MOD_STS_STANDSTILL__CHOICE (6u)
#define EV6_ADAS_RAD_140H_ACC_MOD_STS_FAILURE_MODE_CHOICE (7u)

#define EV6_ADAS_RAD_140H_AEB_PRE_WARNING_ACTIVE_NOT__ACTIVE_CHOICE (0u)
#define EV6_ADAS_RAD_140H_AEB_PRE_WARNING_ACTIVE_ACTIVE_CHOICE (1u)

#define EV6_ADAS_RAD_140H_AEB_LATENT_WARNING_ACTIVE_NOT__ACTIVE_CHOICE (0u)
#define EV6_ADAS_RAD_140H_AEB_LATENT_WARNING_ACTIVE_ACTIVE_CHOICE (1u)

#define EV6_ADAS_RAD_140H_ACC_OBJ_VALID_INVALID__CHOICE (0u)
#define EV6_ADAS_RAD_140H_ACC_OBJ_VALID_VALID__CHOICE (1u)

#define EV6_ADAS_RAD_140H_ACC_TAR_OBJ_BAR_DIS_NO_DISPLAY_CHOICE (0u)
#define EV6_ADAS_RAD_140H_ACC_TAR_OBJ_BAR_DIS_DISTANCE_1_ONE_BAR__CHOICE (1u)
#define EV6_ADAS_RAD_140H_ACC_TAR_OBJ_BAR_DIS_DISTANCE_2_TWO_BAR_CHOICE (2u)
#define EV6_ADAS_RAD_140H_ACC_TAR_OBJ_BAR_DIS_DISTANCE_3_THREE_BAR_CHOICE (3u)
#define EV6_ADAS_RAD_140H_ACC_TAR_OBJ_BAR_DIS_DISTANCE_4_FOUR_BAR__CHOICE (4u)

#define EV6_ADAS_RAD_140H_ACC_TIM_GAP_SET_NO_DISPLAY_CHOICE (0u)
#define EV6_ADAS_RAD_140H_ACC_TIM_GAP_SET_BAR_1_CHOICE (1u)
#define EV6_ADAS_RAD_140H_ACC_TIM_GAP_SET_BAR_2_CHOICE (2u)
#define EV6_ADAS_RAD_140H_ACC_TIM_GAP_SET_BAR_3_CHOICE (3u)
#define EV6_ADAS_RAD_140H_ACC_TIM_GAP_SET_BAR_4_CHOICE (4u)

#define EV6_ADAS_CAM_10_AH_CAMERA_LKA_WORKING_NOT__WORKING_CHOICE (0u)
#define EV6_ADAS_CAM_10_AH_CAMERA_LKA_WORKING_WORKING_CHOICE (1u)

#define EV6_ADAS_CAM_10_AH_CAMERA_LDW_STATUS_OFF__CHOICE (0u)
#define EV6_ADAS_CAM_10_AH_CAMERA_LDW_STATUS_ON_CHOICE (1u)
#define EV6_ADAS_CAM_10_AH_CAMERA_LDW_STATUS_ERROR_CHOICE (2u)
#define EV6_ADAS_CAM_10_AH_CAMERA_LDW_STATUS_STANDBY_CHOICE (3u)

#define EV6_ADAS_CAM_10_AH_CAMERA_FAULT_NORMAL_CHOICE (0u)
#define EV6_ADAS_CAM_10_AH_CAMERA_FAULT_INITIALIZING_CHOICE (1u)
#define EV6_ADAS_CAM_10_AH_CAMERA_FAULT_SHUTDOWN_CHOICE (2u)
#define EV6_ADAS_CAM_10_AH_CAMERA_FAULT_ERROR_CHOICE (3u)

#define EV6_ADAS_CAM_10_AH_CAMERA_CALIBRATED_STATUS_NORMAL_CHOICE (0u)
#define EV6_ADAS_CAM_10_AH_CAMERA_CALIBRATED_STATUS_NO__CALIBRATED_CHOICE (1u)

#define EV6_ADAS_CAM_10_AH_CAMERA_2_L_LANE_STATUS_NO__LANE_DETECTED_CHOICE (0u)
#define EV6_ADAS_CAM_10_AH_CAMERA_2_L_LANE_STATUS_LANE_DETECTED_CHOICE (1u)

#define EV6_ADAS_CAM_10_AH_CAMERA_LDWR_LANE_STATUS_NO__LANE_DETECTED_CHOICE (0u)
#define EV6_ADAS_CAM_10_AH_CAMERA_LDWR_LANE_STATUS_LANE_DETECTED_CHOICE (1u)
#define EV6_ADAS_CAM_10_AH_CAMERA_LDWR_LANE_STATUS_LANE_WARNING_CHOICE (2u)

#define EV6_ADAS_CAM_10_AH_CAMERA_LDWL_LANE_STATUS_NO__LANE_DETECTED_CHOICE (0u)
#define EV6_ADAS_CAM_10_AH_CAMERA_LDWL_LANE_STATUS_LANE_DETECTED_CHOICE (1u)
#define EV6_ADAS_CAM_10_AH_CAMERA_LDWL_LANE_STATUS_LANE_WARNING_CHOICE (2u)

#define EV6_ADAS_CAM_10_AH_CAMERA_LKS_STATUS_OFF_CHOICE (0u)
#define EV6_ADAS_CAM_10_AH_CAMERA_LKS_STATUS_ON_CHOICE (1u)
#define EV6_ADAS_CAM_10_AH_CAMERA_LKS_STATUS_ERROR_CHOICE (2u)
#define EV6_ADAS_CAM_10_AH_CAMERA_LKS_STATUS_STANDBY_CHOICE (3u)

#define EV6_ADAS_CAM_10_AH_IHC_STS_INACTIVE_CHOICE (0u)
#define EV6_ADAS_CAM_10_AH_IHC_STS_ACTIVE_CHOICE (1u)
#define EV6_ADAS_CAM_10_AH_IHC_STS_ERROR_CHOICE (2u)

#define EV6_ADAS_CAM_10_AH_TSR_STS_INACTIVE_CHOICE (0u)
#define EV6_ADAS_CAM_10_AH_TSR_STS_ACTIVE_CHOICE (1u)
#define EV6_ADAS_CAM_10_AH_TSR_STS_ERROR_CHOICE (2u)

#define EV6_ADAS_CAM_10_AH_CAMERA_HAND_OFF_WARNING_NORMAL_CHOICE (0u)
#define EV6_ADAS_CAM_10_AH_CAMERA_HAND_OFF_WARNING_WARNING_CHOICE (1u)

#define EV6_ADAS_CAM_10_AH_CAMERA_2_R_LANE_STATUS_NO__LANE_DETECTED_CHOICE (0u)
#define EV6_ADAS_CAM_10_AH_CAMERA_2_R_LANE_STATUS_LANE_DETECTED_CHOICE (1u)

#define EV6_ADAS_CAM_10_AH_CAM_VEHICLE_MONITOR_NO_EXIST_CHOICE (0u)
#define EV6_ADAS_CAM_10_AH_CAM_VEHICLE_MONITOR_EXIST_CHOICE (1u)

#define EV6_ADAS_CAM_10_AH_CAM_PEDESTRIAN_MONITOR_NO_EXIST_CHOICE (0u)
#define EV6_ADAS_CAM_10_AH_CAM_PEDESTRIAN_MONITOR_EXIST_CHOICE (1u)

#define EV6_ADAS_CAM_10_AH_ICA_MODE_OFF_CHOICE (0u)
#define EV6_ADAS_CAM_10_AH_ICA_MODE_ICA_TJA_ACTIVE_CHOICE (1u)
#define EV6_ADAS_CAM_10_AH_ICA_MODE_ICA_TJA_STANDBY_CHOICE (2u)
#define EV6_ADAS_CAM_10_AH_ICA_MODE_ICA_TJA_DEGRADE_MODE_CHOICE (3u)
#define EV6_ADAS_CAM_10_AH_ICA_MODE_ERROR_CHOICE (4u)

#define EV6_ADAS_CAM_10_AH_IHC_FLA_ACTIVE_NO_REQUEST_CHOICE (0u)
#define EV6_ADAS_CAM_10_AH_IHC_FLA_ACTIVE_ONLY_DIPPED_BEAM__ON_CHOICE (1u)
#define EV6_ADAS_CAM_10_AH_IHC_FLA_ACTIVE_ONLY_HIGH_BEAM__ON_CHOICE (2u)

#define EV6_MCU_97H_MCU_MOT_SPD_VALID_VALID_CHOICE (0u)
#define EV6_MCU_97H_MCU_MOT_SPD_VALID_INVALID_CHOICE (1u)

#define EV6_MCU_97H_MCU_MOT_TOQ_VALID_VALID_CHOICE (0u)
#define EV6_MCU_97H_MCU_MOT_TOQ_VALID_IN_VALID_CHOICE (1u)

#define EV6_MCU_97H_MCU_MOT_WORKING_STS_INTI_________CHOICE (0u)
#define EV6_MCU_97H_MCU_MOT_WORKING_STS_IDLE_____________CHOICE (1u)
#define EV6_MCU_97H_MCU_MOT_WORKING_STS_STANDBY______0___CHOICE (2u)
#define EV6_MCU_97H_MCU_MOT_WORKING_STS_TORQUE__CTRL__MODE__________CHOICE (3u)
#define EV6_MCU_97H_MCU_MOT_WORKING_STS_SPEED__CTRL__MODE___________CHOICE (4u)
#define EV6_MCU_97H_MCU_MOT_WORKING_STS_ACTIVE__DISCHARGE__MODE_CHOICE (5u)
#define EV6_MCU_97H_MCU_MOT_WORKING_STS_RESERVED_CHOICE (6u)
#define EV6_MCU_97H_MCU_MOT_WORKING_STS_INVALID_____CHOICE (7u)

#define EV6_ESP_125H_ESP_MASTER_CYLIND_BRAKE_PRESS_VALID_VALID__CHOICE (0u)
#define EV6_ESP_125H_ESP_MASTER_CYLIND_BRAKE_PRESS_VALID_INVALID_CHOICE (1u)

#define EV6_BCM_105H_HAZARD_STATUS_OFF_CHOICE (0u)
#define EV6_BCM_105H_HAZARD_STATUS_ON_CHOICE (1u)

#define EV6_BCM_105H_RIGHT_TURN_STATUS_OFF_CHOICE (0u)
#define EV6_BCM_105H_RIGHT_TURN_STATUS_ON_CHOICE (1u)

#define EV6_BCM_105H_LEFT_TURN_STATUS_OFF_CHOICE (0u)
#define EV6_BCM_105H_LEFT_TURN_STATUS_ON_CHOICE (1u)

#define EV6_BCM_105H_REAR_FOG_STATUS_OFF_CHOICE (0u)
#define EV6_BCM_105H_REAR_FOG_STATUS_ON_CHOICE (1u)

#define EV6_BCM_105H_FRONT_FOG_STATUS_OFF_CHOICE (0u)
#define EV6_BCM_105H_FRONT_FOG_STATUS_ON_CHOICE (1u)

#define EV6_BCM_105H_LOW_BEAM_STATUS_OFF_CHOICE (0u)
#define EV6_BCM_105H_LOW_BEAM_STATUS_ON_CHOICE (1u)

#define EV6_BCM_105H_HIGH_BEAM_STATUS_OFF_CHOICE (0u)
#define EV6_BCM_105H_HIGH_BEAM_STATUS_ON_CHOICE (1u)

#define EV6_BCM_105H_REAR_WIPER_STATUS_STOP_CHOICE (0u)
#define EV6_BCM_105H_REAR_WIPER_STATUS_LOW__SPEED_CHOICE (1u)
#define EV6_BCM_105H_REAR_WIPER_STATUS_INVALID_CHOICE (7u)

#define EV6_BCM_105H_BRAKE_LAMP_STATUS_OFF_CHOICE (0u)
#define EV6_BCM_105H_BRAKE_LAMP_STATUS_ON_CHOICE (1u)

#define EV6_BCM_105H_FRONT_WIPER_STATUS_STOP_CHOICE (0u)
#define EV6_BCM_105H_FRONT_WIPER_STATUS_LOW__SPEED_CHOICE (1u)
#define EV6_BCM_105H_FRONT_WIPER_STATUS_HIGH__SPEED_CHOICE (2u)
#define EV6_BCM_105H_FRONT_WIPER_STATUS_INTERRUPT_CHOICE (3u)
#define EV6_BCM_105H_FRONT_WIPER_STATUS_WASH__RESERVED__CHOICE (4u)
#define EV6_BCM_105H_FRONT_WIPER_STATUS_INVALID_CHOICE (7u)

#define EV6_BCM_105H_RAINSENSOR_WIPE_REQUEST_WIPER__OFF_CHOICE (0u)
#define EV6_BCM_105H_RAINSENSOR_WIPE_REQUEST_LOW__SPEED__WIPE__SINGLE__CHOICE (1u)
#define EV6_BCM_105H_RAINSENSOR_WIPE_REQUEST_LOW__SPEED__WIPE__CONTINUOUS__CHOICE (2u)
#define EV6_BCM_105H_RAINSENSOR_WIPE_REQUEST_0X3__HIGH__SPEED__WIPE__CONTINUOUS__CHOICE (3u)

#define EV6_BCM_105H_IHC_SW_STS_OFF_CHOICE (0u)
#define EV6_BCM_105H_IHC_SW_STS_ON_CHOICE (1u)
#define EV6_BCM_105H_IHC_SW_STS_AUTO_CHOICE (2u)
#define EV6_BCM_105H_IHC_SW_STS_ERR_CHOICE (3u)

#define EV6_ACU_021H_DRV_SEAT_BELT_R_ST_LAMP_OFF_______CHOICE (0u)
#define EV6_ACU_021H_DRV_SEAT_BELT_R_ST_FAULT___RESERVED__CHOICE (1u)
#define EV6_ACU_021H_DRV_SEAT_BELT_R_ST_LAMP_ON_______CHOICE (2u)
#define EV6_ACU_021H_DRV_SEAT_BELT_R_ST_RESERVED_CHOICE (3u)

#define EV6_ACU_021H_CRASH_OUTPUT_STS_NO_CRASH_CHOICE (0u)
#define EV6_ACU_021H_CRASH_OUTPUT_STS_FRONT_CHOICE (1u)
#define EV6_ACU_021H_CRASH_OUTPUT_STS_SIDE_CHOICE (2u)
#define EV6_ACU_021H_CRASH_OUTPUT_STS_FRONT_AND_SIDE_CHOICE (3u)

#define EV6_VCU_123H_VCU_BRK_PDL_STS_V_VALID_CHOICE (0u)
#define EV6_VCU_123H_VCU_BRK_PDL_STS_V_INVALID_CHOICE (1u)

#define EV6_VCU_123H_ACC_MINUS_SET_NO_PRESS_CHOICE (0u)
#define EV6_VCU_123H_ACC_MINUS_SET_SHORT__PRESSED_CHOICE (1u)
#define EV6_VCU_123H_ACC_MINUS_SET_LONG__PRESSED_CHOICE (2u)
#define EV6_VCU_123H_ACC_MINUS_SET_0X3__RESERVED_CHOICE (3u)

#define EV6_VCU_123H_ACC_TIME_GAP_SET_NO_PRESS_CHOICE (0u)
#define EV6_VCU_123H_ACC_TIME_GAP_SET_PRESSED_CHOICE (1u)

#define EV6_VCU_123H_ACC_CANCEL_NO_PRESS_CHOICE (0u)
#define EV6_VCU_123H_ACC_CANCEL_PRESSED_CHOICE (1u)

#define EV6_VCU_123H_ACC_MAIN_SWITCH_OFF_CHOICE (0u)
#define EV6_VCU_123H_ACC_MAIN_SWITCH_ACC_MODE_CHOICE (1u)
#define EV6_VCU_123H_ACC_MAIN_SWITCH_ICA_TJ_AMODE_CHOICE (2u)

#define EV6_VCU_123H_VCU_GASPEDAL_OVERRIDE_NO__OVERRIDE_CHOICE (0u)
#define EV6_VCU_123H_VCU_GASPEDAL_OVERRIDE_OVERRIDE_CHOICE (1u)

#define EV6_VCU_123H_VCU_ACCEL_PDL_POS_V_VALID__CHOICE (0u)
#define EV6_VCU_123H_VCU_ACCEL_PDL_POS_V_INVALID_CHOICE (1u)

#define EV6_VCU_123H_VCU_BRK_PDL_STS_NOT_PRESSED__CHOICE (0u)
#define EV6_VCU_123H_VCU_BRK_PDL_STS_PRESSED_CHOICE (1u)

#define EV6_VCU_123H_ACC_PLUS_RESUME_NO_PRESS_CHOICE (0u)
#define EV6_VCU_123H_ACC_PLUS_RESUME_SHORT__PRESSED_CHOICE (1u)
#define EV6_VCU_123H_ACC_PLUS_RESUME_LONG__PRESSED_CHOICE (2u)
#define EV6_VCU_123H_ACC_PLUS_RESUME_RESERVED_CHOICE (3u)

#define EV6_IBOOSTER_13_CH_BRAKE_PEDAL_APPLIED_BRAKE_PEDAL_NOT_APPLIED_CHOICE (0u)
#define EV6_IBOOSTER_13_CH_BRAKE_PEDAL_APPLIED_BRAKE_PEDAL_APPLIED_CHOICE (1u)

#define EV6_IBOOSTER_13_CH_AEB_ACTIVE_NO_ACTIVE_CHOICE (0u)
#define EV6_IBOOSTER_13_CH_AEB_ACTIVE_ACTIVE_CHOICE (1u)

#define EV6_IBOOSTER_13_CH_EBA_ACTIVE_NO_ACTIVE_CHOICE (0u)
#define EV6_IBOOSTER_13_CH_EBA_ACTIVE_ACTIVE_CHOICE (1u)

#define EV6_IBOOSTER_13_CH_AWB_ACTIVE_NO_ACTIVE_CHOICE (0u)
#define EV6_IBOOSTER_13_CH_AWB_ACTIVE_ACTIVE_CHOICE (1u)

#define EV6_IBOOSTER_13_CH_PREFILL_ACTIVE_NO_ACTIVE_CHOICE (0u)
#define EV6_IBOOSTER_13_CH_PREFILL_ACTIVE_ACTIVE_CHOICE (1u)

#define EV6_IBOOSTER_13_CH_IBOOSTER_CONTROL_STATE_DISABLE_CHOICE (0u)
#define EV6_IBOOSTER_13_CH_IBOOSTER_CONTROL_STATE_ENABLE_CHOICE (1u)
#define EV6_IBOOSTER_13_CH_IBOOSTER_CONTROL_STATE_RESERVED_2_CHOICE (2u)
#define EV6_IBOOSTER_13_CH_IBOOSTER_CONTROL_STATE_RESERVED_3_CHOICE (3u)

#define EV6_IBOOSTER_13_CH_EXT_REQ_STATUS_EBR_NOT_INITIALIZED_CHOICE (0u)
#define EV6_IBOOSTER_13_CH_EXT_REQ_STATUS_EBR_NOT_AVAILABLE_CHOICE (1u)
#define EV6_IBOOSTER_13_CH_EXT_REQ_STATUS_EBR_AVAILABLE_CHOICE (2u)
#define EV6_IBOOSTER_13_CH_EXT_REQ_STATUS_RESERVED_CHOICE (3u)

#define EV6_IBOOSTER_13_CH_BRAKE_PEDAL_APPLIED_Q_NOT_INITIALIZED_CHOICE (0u)
#define EV6_IBOOSTER_13_CH_BRAKE_PEDAL_APPLIED_Q_NORMAL_CHOICE (1u)
#define EV6_IBOOSTER_13_CH_BRAKE_PEDAL_APPLIED_Q_FAULTY_CHOICE (2u)
#define EV6_IBOOSTER_13_CH_BRAKE_PEDAL_APPLIED_Q_RESERVED_CHOICE (3u)

#define EV6_IBOOSTER_13_AH_S_OUTPUT_ROD_DRIVER_Q_NOT_INITIALIZED_CHOICE (0u)
#define EV6_IBOOSTER_13_AH_S_OUTPUT_ROD_DRIVER_Q_NORMAL_CHOICE (1u)
#define EV6_IBOOSTER_13_AH_S_OUTPUT_ROD_DRIVER_Q_FAULTY_CHOICE (2u)
#define EV6_IBOOSTER_13_AH_S_OUTPUT_ROD_DRIVER_Q_RESERVED_CHOICE (3u)

#define EV6_ADAS_RAD_118H_AEB_AEB_ACTIVE_NO_ACTIVE_CHOICE (0u)
#define EV6_ADAS_RAD_118H_AEB_AEB_ACTIVE_ACTIVE_CHOICE (1u)

#define EV6_ADAS_RAD_118H_AEB_EBA_ACTIVE_NO_ACTIVE_CHOICE (0u)
#define EV6_ADAS_RAD_118H_AEB_EBA_ACTIVE_ACTIVE_CHOICE (1u)

#define EV6_ADAS_RAD_118H_AEB_AWB_ACTIVE_NO_ACTIVE_CHOICE (0u)
#define EV6_ADAS_RAD_118H_AEB_AWB_ACTIVE_ACTIVE_CHOICE (1u)

#define EV6_ADAS_RAD_118H_AEB_FCW_ACTIVE_NOT__ACTIVE_CHOICE (0u)
#define EV6_ADAS_RAD_118H_AEB_FCW_ACTIVE_ACTIVE_CHOICE (1u)

#define EV6_ADAS_RAD_118H_AEB_PREFILL_ACTIVE_NOT__ACTIVE_CHOICE (0u)
#define EV6_ADAS_RAD_118H_AEB_PREFILL_ACTIVE_ACTIVE_CHOICE (1u)

#define EV6_ADAS_RAD_118H_ACC_ENG_TRQ_REQ_ACTIVE_NO_REQUEST_CHOICE (0u)
#define EV6_ADAS_RAD_118H_ACC_ENG_TRQ_REQ_ACTIVE_REQUEST_CHOICE (1u)

#define EV6_ADAS_RAD_118H_ACC_DECEL_REQ_NO_REQUEST_CHOICE (0u)
#define EV6_ADAS_RAD_118H_ACC_DECEL_REQ_REQUEST_CHOICE (1u)

#define EV6_ADAS_RAD_118H_ACC_DEC_TO_STOP_NO_DEMAND_CHOICE (0u)
#define EV6_ADAS_RAD_118H_ACC_DEC_TO_STOP_DEMAND_CHOICE (1u)

#define EV6_ADAS_RAD_118H_AEB_AEB_STS_AEB_OFF_CHOICE (0u)
#define EV6_ADAS_RAD_118H_AEB_AEB_STS_AEB_ON_CHOICE (1u)

#define EV6_ADAS_RAD_118H_AEB_TARGET_DETECTED_NOT_DETECTED_CHOICE (0u)
#define EV6_ADAS_RAD_118H_AEB_TARGET_DETECTED_DETECTED_CHOICE (1u)

#define EV6_ADAS_RAD_118H_AEB_AWB_LEVEL_NO_LEVEL_CHOICE (0u)
#define EV6_ADAS_RAD_118H_AEB_AWB_LEVEL_LEVEL_1_CHOICE (1u)
#define EV6_ADAS_RAD_118H_AEB_AWB_LEVEL_LEVEL_2_CHOICE (2u)
#define EV6_ADAS_RAD_118H_AEB_AWB_LEVEL_LEVEL_3_CHOICE (3u)
#define EV6_ADAS_RAD_118H_AEB_AWB_LEVEL_LEVEL_4_CHOICE (4u)

#define EV6_ADAS_RAD_118H_AEB_AEB_FAILURE_NO_FAILURE_CHOICE (0u)
#define EV6_ADAS_RAD_118H_AEB_AEB_FAILURE_FAILURE_CHOICE (1u)

#define EV6_APA_92H_APA_VEHICLE_STOP_RQ___NO__REQUEST_0__CHOICE (0u)
#define EV6_APA_92H_APA_VEHICLE_STOP_RQ___REQUEST_1__CHOICE (1u)

#define EV6_APA_92H_APA_VEHICLE_STOP_RQ_VD___VALID_0__CHOICE (0u)
#define EV6_APA_92H_APA_VEHICLE_STOP_RQ_VD___INVALID_1__CHOICE (1u)

#define EV6_APA_92H_APA_SYSTEM_STATUS___DISABLE_0__CHOICE (0u)
#define EV6_APA_92H_APA_SYSTEM_STATUS___ENABLE_1__CHOICE (1u)
#define EV6_APA_92H_APA_SYSTEM_STATUS___ACTIVE_2__CHOICE (2u)
#define EV6_APA_92H_APA_SYSTEM_STATUS___FAILED_3__CHOICE (3u)

#define EV6_APA_91H_APA_EPS_CONTROL_RQ___NO__REQUEST_0__CHOICE (0u)
#define EV6_APA_91H_APA_EPS_CONTROL_RQ___REQUEST_1__CHOICE (1u)

#define EV6_APA_91H_APA_EPS_CONTROL_RQ_VD___VALID_0__CHOICE (0u)
#define EV6_APA_91H_APA_EPS_CONTROL_RQ_VD___INVALID_1__CHOICE (1u)

#define EV6_APA_91H_APA_DEGREE_REQ_SIGN_INITAL_VALUE_0__CHOICE (0u)
#define EV6_APA_91H_APA_DEGREE_REQ_SIGN_POSITIVE_1__CHOICE (1u)
#define EV6_APA_91H_APA_DEGREE_REQ_SIGN_NEGATIVE_2__CHOICE (2u)
#define EV6_APA_91H_APA_DEGREE_REQ_SIGN______________________3__CHOICE (3u)

#define EV6_IHU_2_F_CH_TSR_SW_STS_INVALID_VALUE_CHOICE (0u)
#define EV6_IHU_2_F_CH_TSR_SW_STS_CLOSE_CHOICE (1u)
#define EV6_IHU_2_F_CH_TSR_SW_STS_OPEN_CHOICE (2u)
#define EV6_IHU_2_F_CH_TSR_SW_STS_ERROR_CHOICE (3u)

#define EV6_IHU_2_F_CH_INTELLIGENT_HIGH_BEAM_SW_STS_OFF_CHOICE (0u)
#define EV6_IHU_2_F_CH_INTELLIGENT_HIGH_BEAM_SW_STS_ON_CHOICE (1u)
#define EV6_IHU_2_F_CH_INTELLIGENT_HIGH_BEAM_SW_STS_ERR_CHOICE (2u)

#define EV6_IHU_2_F_CH_LKA_SWITCH_STATUS_INVALID_VALUE_CHOICE (0u)
#define EV6_IHU_2_F_CH_LKA_SWITCH_STATUS_CLOSE_CHOICE (1u)
#define EV6_IHU_2_F_CH_LKA_SWITCH_STATUS_OPEN_CHOICE (2u)
#define EV6_IHU_2_F_CH_LKA_SWITCH_STATUS_ERROR_CHOICE (3u)

#define EV6_IHU_2_F_CH_LDW_SWITCH_STATUS_INVALID_VALUE_CHOICE (0u)
#define EV6_IHU_2_F_CH_LDW_SWITCH_STATUS_CLOSE_CHOICE (1u)
#define EV6_IHU_2_F_CH_LDW_SWITCH_STATUS_OPEN_CHOICE (2u)
#define EV6_IHU_2_F_CH_LDW_SWITCH_STATUS_ERROR_CHOICE (3u)

#define EV6_IHU_2_F_CH_FCW_AEB_SWITCH_STATUS_OFF_CHOICE (0u)
#define EV6_IHU_2_F_CH_FCW_AEB_SWITCH_STATUS_ON_CHOICE (1u)

#define EV6_IHU_2_F_CH_IHU_BSD_SWITCH_STATUS_INVALID_VALUE_CHOICE (0u)
#define EV6_IHU_2_F_CH_IHU_BSD_SWITCH_STATUS_CLOSE_CHOICE (1u)
#define EV6_IHU_2_F_CH_IHU_BSD_SWITCH_STATUS_OPEN_CHOICE (2u)
#define EV6_IHU_2_F_CH_IHU_BSD_SWITCH_STATUS_ERROR_CHOICE (3u)

#define EV6_IHU_2_F_CH_IHU_EPS_STEERING_ASSISTANCE______3__CHOICE (3u)

#define EV6_APA_264H_APA_OBSTACLE_DETECTION_STATUS___NO_OBSTACLE_DETECTED_0__CHOICE (0u)
#define EV6_APA_264H_APA_OBSTACLE_DETECTION_STATUS___OBSTACLE_DETECTED_1__CHOICE (1u)

#define EV6_VCU_200H_VCU_DRIVE_MODE_NOMAL__CONFORT__0__CHOICE (0u)
#define EV6_VCU_200H_VCU_DRIVE_MODE_ECO_1__CHOICE (1u)
#define EV6_VCU_200H_VCU_DRIVE_MODE_SPORT_2__CHOICE (2u)
#define EV6_VCU_200H_VCU_DRIVE_MODE_LIMP_HOME__MODE_3__CHOICE (3u)
#define EV6_VCU_200H_VCU_DRIVE_MODE_AUTO_DRIVE_4__CHOICE (4u)
#define EV6_VCU_200H_VCU_DRIVE_MODE_RESERVED_5__CHOICE (5u)
#define EV6_VCU_200H_VCU_DRIVE_MODE_RESERVED_6__CHOICE (6u)
#define EV6_VCU_200H_VCU_DRIVE_MODE_RESERVED_7__CHOICE (7u)

#define EV6_VCU_200H_VCU_PT_RDY___FALSE__0__CHOICE (0u)
#define EV6_VCU_200H_VCU_PT_RDY___TRUE_1__CHOICE (1u)

#define EV6_VCU_200H_VCU_SHIFT_LEVEL_POSITION_INVALID_CHOICE (0u)
#define EV6_VCU_200H_VCU_SHIFT_LEVEL_POSITION_REVERES_CHOICE (1u)
#define EV6_VCU_200H_VCU_SHIFT_LEVEL_POSITION_NETURAL_CHOICE (2u)
#define EV6_VCU_200H_VCU_SHIFT_LEVEL_POSITION_DRIVE_CHOICE (3u)
#define EV6_VCU_200H_VCU_SHIFT_LEVEL_POSITION_SPORT_CHOICE (4u)
#define EV6_VCU_200H_VCU_SHIFT_LEVEL_POSITION_PARKING_CHOICE (5u)
#define EV6_VCU_200H_VCU_SHIFT_LEVEL_POSITION_RESERVED_6_CHOICE (6u)
#define EV6_VCU_200H_VCU_SHIFT_LEVEL_POSITION_RESERVED_7_CHOICE (7u)

#define EV6_VCU_200H_VCU_GEAR_CONTROL_MODULE_DRIVER__CONTROL_CHOICE (0u)
#define EV6_VCU_200H_VCU_GEAR_CONTROL_MODULE_ACC__CONTROL_CHOICE (1u)
#define EV6_VCU_200H_VCU_GEAR_CONTROL_MODULE_APA__CONTROL_CHOICE (2u)
#define EV6_VCU_200H_VCU_GEAR_CONTROL_MODULE_REMOTE__CONTROL_CHOICE (3u)

#define EV6_VCU_200H_VCU_TORQUE_CONTROL_MODULE_DRIVER__CONTROL_CHOICE (0u)
#define EV6_VCU_200H_VCU_TORQUE_CONTROL_MODULE_ACC__CONTROL_CHOICE (1u)
#define EV6_VCU_200H_VCU_TORQUE_CONTROL_MODULE_APA__CONTROL_CHOICE (2u)
#define EV6_VCU_200H_VCU_TORQUE_CONTROL_MODULE_REMOTE__CONTROL_CHOICE (3u)

#define EV6_VCU_200H_VCU_BRAKE_CONTROL_MODULE_DRIVER__CONTROL_CHOICE (0u)
#define EV6_VCU_200H_VCU_BRAKE_CONTROL_MODULE_ACC__CONTROL_CHOICE (1u)
#define EV6_VCU_200H_VCU_BRAKE_CONTROL_MODULE_APA__CONTROL_CHOICE (2u)
#define EV6_VCU_200H_VCU_BRAKE_CONTROL_MODULE_REMOTE__CONTROL_CHOICE (3u)

#define EV6_EPS_131H_EPS_RESP_APA_WHI_ANG___NOT__AVAILABLE_0__CHOICE (0u)
#define EV6_EPS_131H_EPS_RESP_APA_WHI_ANG___AVAILABLE_1__CHOICE (1u)

#define EV6_EPS_131H_EPS_CAMERA_CTRL_STATUS___INITIALIZATION_0__CHOICE (0u)
#define EV6_EPS_131H_EPS_CAMERA_CTRL_STATUS_AVAILABLE_1__CHOICE (1u)
#define EV6_EPS_131H_EPS_CAMERA_CTRL_STATUS_MODE1__ACTIVE_2__CHOICE (2u)
#define EV6_EPS_131H_EPS_CAMERA_CTRL_STATUS_MODE2__ACTIVE_3__CHOICE (3u)
#define EV6_EPS_131H_EPS_CAMERA_CTRL_STATUS_ABORT_4__CHOICE (4u)
#define EV6_EPS_131H_EPS_CAMERA_CTRL_STATUS_APA__ACTIVE_5__CHOICE (5u)
#define EV6_EPS_131H_EPS_CAMERA_CTRL_STATUS_APA__PRE_ACTIVE_6__CHOICE (6u)
#define EV6_EPS_131H_EPS_CAMERA_CTRL_STATUS_RESERVED_7__CHOICE (7u)

#define EV6_EPS_131H_EPS_DRIVER_INTERVENTION_STEERING_V_VALID_0__CHOICE (0u)
#define EV6_EPS_131H_EPS_DRIVER_INTERVENTION_STEERING_V_INVALID_1__CHOICE (1u)

#define EV6_EPS_131H_EPS_DRIVER_INTERVENTION_STEERING_NOT__DRIVER_INTERVENTION_0__CHOICE (0u)
#define EV6_EPS_131H_EPS_DRIVER_INTERVENTION_STEERING_DRIVER_INTERVENTION_1__CHOICE (1u)

#define EV6_EPS_131H_EPS_TORQUE_V_INVALID_0__CHOICE (0u)
#define EV6_EPS_131H_EPS_TORQUE_V_VALID_1__CHOICE (1u)

#define EV6_EPS_131H_EPS_WORK_MODE_STANDARD_0__CHOICE (0u)
#define EV6_EPS_131H_EPS_WORK_MODE_COMFORT_1__CHOICE (1u)
#define EV6_EPS_131H_EPS_WORK_MODE_SPORTS_2__CHOICE (2u)
#define EV6_EPS_131H_EPS_WORK_MODE_RESERVED_3__CHOICE (3u)

#define EV6_EPS_131H_EPS_CAMERA_ABORT_STATUS_NO__ERROR_0__CHOICE (0u)
#define EV6_EPS_131H_EPS_CAMERA_ABORT_STATUS_EPS__ERROR_1__CHOICE (1u)
#define EV6_EPS_131H_EPS_CAMERA_ABORT_STATUS_DRIVER__INTERVENTION_DETECTED_2__CHOICE (2u)
#define EV6_EPS_131H_EPS_CAMERA_ABORT_STATUS_COMMUNICATION_ERROR_3__CHOICE (3u)
#define EV6_EPS_131H_EPS_CAMERA_ABORT_STATUS___INVALID_CONTROL_REQUEST_4__CHOICE (4u)
#define EV6_EPS_131H_EPS_CAMERA_ABORT_STATUS_HANDSHAKE_LOGIC_ERROR_5__CHOICE (5u)
#define EV6_EPS_131H_EPS_CAMERA_ABORT_STATUS_VEHICLE_SPEED_TOO_HIGH_6__CHOICE (6u)
#define EV6_EPS_131H_EPS_CAMERA_ABORT_STATUS_STEERING_ANGLE_REQUEST_CHANGE_EXCEEDED_THE_LIMITATION_7__CHOICE (7u)
#define EV6_EPS_131H_EPS_CAMERA_ABORT_STATUS_STEERING_ANGLE_REQUEST_EXCEEDED_THE_LIMITATION_8__CHOICE (8u)
#define EV6_EPS_131H_EPS_CAMERA_ABORT_STATUS_STEERING_WHEEL_VELOCITY_REQUEST_EXCEEDED_THE_LIMITATION_9__CHOICE (9u)
#define EV6_EPS_131H_EPS_CAMERA_ABORT_STATUS_STEERING_TORQUE_REQUEST_EXCEEDED_THE_LIMITATION_10__CHOICE (10u)
#define EV6_EPS_131H_EPS_CAMERA_ABORT_STATUS_STEERING_TORQUE_REQUEST_CHANGE_EXCEEDED_THE__IIMITATION_11__CHOICE (11u)

#define EV6_EPS_131H_HAND_DETECTION________0__CHOICE (0u)
#define EV6_EPS_131H_HAND_DETECTION______1__CHOICE (1u)

#define EV6_EPS_117H_EPS_STEERING_ASSISTANCE______3__CHOICE (3u)

#define EV6_EPS_117H_EPS_FLR_STS______0__CHOICE (0u)
#define EV6_EPS_117H_EPS_FLR_STS__________1__CHOICE (1u)
#define EV6_EPS_117H_EPS_FLR_STS__________2__CHOICE (2u)
#define EV6_EPS_117H_EPS_FLR_STS__________3__CHOICE (3u)

#define EV6_EPS_117H_STRG_WHL_ANG_SNSR_CAL_STS_SENSOR_NOT_CALIBRATED_0__CHOICE (0u)
#define EV6_EPS_117H_STRG_WHL_ANG_SNSR_CAL_STS_SENSOR_CALIBRATED_1__CHOICE (1u)

#define EV6_EPS_117H_STRG_WHL_ANG_V_INVALID_0__CHOICE (0u)
#define EV6_EPS_117H_STRG_WHL_ANG_V_VALID_1__CHOICE (1u)

#define EV6_ADAS_CAM_107H_CAMERA_DEGREE_REQ_VALID_INVALID_0__CHOICE (0u)
#define EV6_ADAS_CAM_107H_CAMERA_DEGREE_REQ_VALID_VALID_1__CHOICE (1u)

#define EV6_ADAS_CAM_107H_CAMERA_TORQUE_REQ_VALID_INVALID_0__CHOICE (0u)
#define EV6_ADAS_CAM_107H_CAMERA_TORQUE_REQ_VALID_VALID_1__CHOICE (1u)

#define EV6_ADAS_CAM_107H_CAMERA_SYS_STATUS_TO_EPS__OFF_0__CHOICE (0u)
#define EV6_ADAS_CAM_107H_CAMERA_SYS_STATUS_TO_EPS___READY_1__CHOICE (1u)
#define EV6_ADAS_CAM_107H_CAMERA_SYS_STATUS_TO_EPS___MODE1__ACTIVE_2__CHOICE (2u)
#define EV6_ADAS_CAM_107H_CAMERA_SYS_STATUS_TO_EPS___MODE2__ACTIVE_3__CHOICE (3u)
#define EV6_ADAS_CAM_107H_CAMERA_SYS_STATUS_TO_EPS___ERROR_4__CHOICE (4u)

#define EV6_ESP_104H_AVH_STS_OFF_CHOICE (0u)
#define EV6_ESP_104H_AVH_STS_STANDBY__CHOICE (1u)
#define EV6_ESP_104H_AVH_STS_ACTIVE_CHOICE (2u)

#define EV6_ESP_104H_AVH_AVAILABLE_NOT_AVAILABLE_CHOICE (0u)
#define EV6_ESP_104H_AVH_AVAILABLE___AVAILABLE_CHOICE (1u)

#define EV6_ESP_104H_ABS_FAIL_STS___NO_FAILURE_0__CHOICE (0u)
#define EV6_ESP_104H_ABS_FAIL_STS___FAILURE_1__CHOICE (1u)

#define EV6_ESP_104H_ABS_ACTIVE___NOT_ACTIVE_0__CHOICE (0u)
#define EV6_ESP_104H_ABS_ACTIVE___ACTIVE_1__CHOICE (1u)

#define EV6_ESP_104H_HDC_AVAILABLE_NOT_AVAILABLE_CHOICE (0u)
#define EV6_ESP_104H_HDC_AVAILABLE_AVAILABLE__CHOICE (1u)

#define EV6_ESP_104H_ESP_FUNC_OFF_STS_UNAVAILABLE__OFF_CHOICE (0u)
#define EV6_ESP_104H_ESP_FUNC_OFF_STS_AVAILABLE__ON_CHOICE (1u)

#define EV6_ESP_104H_ESP_FAIL_STS_NO_FAILURE_CHOICE (0u)
#define EV6_ESP_104H_ESP_FAIL_STS_FAILURE_CHOICE (1u)

#define EV6_ESP_104H_EPB_STS_RELEASED_CHOICE (0u)
#define EV6_ESP_104H_EPB_STS_APPLIED_CHOICE (1u)
#define EV6_ESP_104H_EPB_STS_INPROGRESS_CHOICE (2u)
#define EV6_ESP_104H_EPB_STS_UNKNOW_CHOICE (3u)

#define EV6_ESP_104H_EBD_FAIL_STS_NO_FAILURE_CHOICE (0u)
#define EV6_ESP_104H_EBD_FAIL_STS_FAILURE_CHOICE (1u)

#define EV6_ESP_104H_EBD_ACTIVE_NOT_ACTIVE_CHOICE (0u)
#define EV6_ESP_104H_EBD_ACTIVE_ACTIVE_CHOICE (1u)

#define EV6_ESP_104H_ESP_ACTIVE_NOT_ACTIVE_CHOICE (0u)
#define EV6_ESP_104H_ESP_ACTIVE_ACTIVE_CHOICE (1u)

#define EV6_ESP_104H_HHC_FAIL_STS_NO_FAILURE_CHOICE (0u)
#define EV6_ESP_104H_HHC_FAIL_STS_FAILURE_CHOICE (1u)

#define EV6_ESP_104H_HHC_ACTIVE_NOT_ACTIVE_CHOICE (0u)
#define EV6_ESP_104H_HHC_ACTIVE_ACTIVE_CHOICE (1u)

#define EV6_ESP_104H_HDC_STS_OFF_CHOICE (0u)
#define EV6_ESP_104H_HDC_STS_STANDBY_CHOICE (1u)
#define EV6_ESP_104H_HDC_STS_ACTIVE_CHOICE (2u)

#define EV6_ESP_104H_VEHICLE_SPD_VALID___INVALID_0__CHOICE (0u)
#define EV6_ESP_104H_VEHICLE_SPD_VALID___VALID_1__CHOICE (1u)

#define EV6_ESP_101H_RR_WHEEL_DRIVE_DIRECTION___INVALID_0__CHOICE (0u)
#define EV6_ESP_101H_RR_WHEEL_DRIVE_DIRECTION_FORWARD_1__CHOICE (1u)
#define EV6_ESP_101H_RR_WHEEL_DRIVE_DIRECTION___BACKWARD_2__CHOICE (2u)
#define EV6_ESP_101H_RR_WHEEL_DRIVE_DIRECTION___STOP_3__CHOICE (3u)

#define EV6_ESP_101H_RL_WHEEL_DRIVE_DIRECTION___INVALID_0__CHOICE (0u)
#define EV6_ESP_101H_RL_WHEEL_DRIVE_DIRECTION_FORWARD_1__CHOICE (1u)
#define EV6_ESP_101H_RL_WHEEL_DRIVE_DIRECTION___BACKWARD_2__CHOICE (2u)
#define EV6_ESP_101H_RL_WHEEL_DRIVE_DIRECTION___STOP_3__CHOICE (3u)

#define EV6_ESP_101H_FR_WHEEL_DRIVE_DIRECTION___INVALID_0__CHOICE (0u)
#define EV6_ESP_101H_FR_WHEEL_DRIVE_DIRECTION_FORWARD_1__CHOICE (1u)
#define EV6_ESP_101H_FR_WHEEL_DRIVE_DIRECTION_BACKWARD_2__CHOICE (2u)
#define EV6_ESP_101H_FR_WHEEL_DRIVE_DIRECTION_STOP_3__CHOICE (3u)

#define EV6_ESP_101H_FL_WHEEL_DRIVE_DIRECTION_INVALID_0__CHOICE (0u)
#define EV6_ESP_101H_FL_WHEEL_DRIVE_DIRECTION_FORWARD_1__CHOICE (1u)
#define EV6_ESP_101H_FL_WHEEL_DRIVE_DIRECTION_BACKWARD_2__CHOICE (2u)
#define EV6_ESP_101H_FL_WHEEL_DRIVE_DIRECTION___STOP_3__CHOICE (3u)

#define EV6_ESP_101H_WSS_RR_COUNTS_SUM_VALID___INVALID_0__CHOICE (0u)
#define EV6_ESP_101H_WSS_RR_COUNTS_SUM_VALID___VALID_1__CHOICE (1u)

#define EV6_ESP_101H_WSS_RL_COUNTS_SUM_VALID___INVALID_0__CHOICE (0u)
#define EV6_ESP_101H_WSS_RL_COUNTS_SUM_VALID___VALID_1__CHOICE (1u)

#define EV6_ESP_101H_WSS_FR_COUNTS_SUM_VALID___INVALID_0__CHOICE (0u)
#define EV6_ESP_101H_WSS_FR_COUNTS_SUM_VALID___VALID_1__CHOICE (1u)

#define EV6_ESP_101H_WSS_FL_COUNTS_SUM_VALID___INVALID_0__CHOICE (0u)
#define EV6_ESP_101H_WSS_FL_COUNTS_SUM_VALID___VALID_1__CHOICE (1u)

#define EV6_ESP_101H_RR_WHEEL_DRIVE_DIRECTION_VALID___INVALID_0__CHOICE (0u)
#define EV6_ESP_101H_RR_WHEEL_DRIVE_DIRECTION_VALID___VALID_1__CHOICE (1u)

#define EV6_ESP_101H_RL_WHEEL_DRIVE_DIRECTION_VALID___INVALID_0__CHOICE (0u)
#define EV6_ESP_101H_RL_WHEEL_DRIVE_DIRECTION_VALID___VALID_1__CHOICE (1u)

#define EV6_ESP_101H_FR_WHEEL_DRIVE_DIRECTION_VALID___INVALID_0__CHOICE (0u)
#define EV6_ESP_101H_FR_WHEEL_DRIVE_DIRECTION_VALID___VALID_1__CHOICE (1u)

#define EV6_ESP_101H_FL_WHEEL_DRIVE_DIRECTION_VALID___INVALID_0__CHOICE (0u)
#define EV6_ESP_101H_FL_WHEEL_DRIVE_DIRECTION_VALID___VALID_1__CHOICE (1u)

/* Frame Names. */
#define EV6_TBOX_3_E3H_NAME "TBOX_3E3h"
#define EV6_TBOX_2_F_BH_NAME "TBOX_2FBh"
#define EV6_PEPS_211H_NAME "PEPS_211h"
#define EV6_ADAS_RAD_140H_NAME "ADAS_RAD_140h"
#define EV6_ADAS_CAM_10_AH_NAME "ADAS_CAM_10Ah"
#define EV6_MCU_97H_NAME "MCU_97h"
#define EV6_ESP_125H_NAME "ESP_125h"
#define EV6_VCU_119H_NAME "VCU_119h"
#define EV6_BCM_105H_NAME "BCM_105h"
#define EV6_ACU_021H_NAME "ACU_021h"
#define EV6_VCU_123H_NAME "VCU_123h"
#define EV6_IBOOSTER_13_CH_NAME "Ibooster_13Ch"
#define EV6_IBOOSTER_13_AH_NAME "Ibooster_13Ah"
#define EV6_ADAS_RAD_118H_NAME "ADAS_RAD_118h"
#define EV6_APA_92H_NAME "APA_92h"
#define EV6_APA_91H_NAME "APA_91h"
#define EV6_IHU_2_F_CH_NAME "IHU_2FCh"
#define EV6_APA_264H_NAME "APA_264h"
#define EV6_VCU_200H_NAME "VCU_200h"
#define EV6_EPS_131H_NAME "EPS_131h"
#define EV6_EPS_117H_NAME "EPS_117h"
#define EV6_ESP_109H_NAME "ESP_109h"
#define EV6_ADAS_CAM_107H_NAME "ADAS_CAM_107h"
#define EV6_ESP_104H_NAME "ESP_104h"
#define EV6_ESP_102H_NAME "ESP_102h"
#define EV6_ESP_101H_NAME "ESP_101h"

/* Signal Names. */
#define EV6_TBOX_3_E3H_NEW_SIGNAL_213_NAME "New_Signal_213"
#define EV6_TBOX_2_F_BH_TBOX_TSR_SW_STS_NAME "TBOX_TSRSwSts"
#define EV6_TBOX_2_F_BH_TBOX_INTELLIGENT_HIGH_BEAM_SW_STS_NAME "TBOX_IntelligentHighBeamSwSts"
#define EV6_TBOX_2_F_BH_TBOX_LKA_SWITCH_STATUS_NAME "TBOX_LKASwitchStatus"
#define EV6_TBOX_2_F_BH_TBOX_LDW_SWITCH_STATUS_NAME "TBOX_LDWSwitchStatus"
#define EV6_TBOX_2_F_BH_TBOX_FCWAEB_SWITCH_STATUS_NAME "TBOX_FCWAEBSwitchStatus"
#define EV6_TBOX_2_F_BH_TBOX_BSD_SWITCH_STATUS_NAME "TBOX_BSDSwitchStatus"
#define EV6_PEPS_211H_POWER_MODE_PEPS_NAME "POWER_MODE_PEPS"
#define EV6_ADAS_RAD_140H_ACC_TAKE_OVER_REQ_NAME "ACC_TakeOverReq"
#define EV6_ADAS_RAD_140H_ACC_MOD_STS_NAME "ACC_ModSts"
#define EV6_ADAS_RAD_140H_AEB_PRE_WARNING_ACTIVE_NAME "AEB_PreWarningActive"
#define EV6_ADAS_RAD_140H_AEB_LATENT_WARNING_ACTIVE_NAME "AEB_LatentWarningActive"
#define EV6_ADAS_RAD_140H_ACC_OBJ_VALID_NAME "ACC_ObjValid"
#define EV6_ADAS_RAD_140H_ACC_TAR_OBJ_BAR_DIS_NAME "ACC_TarObjBarDis"
#define EV6_ADAS_RAD_140H_ACC_FOLLOW_OBJ_DIS_NAME "ACC_FollowObjDis"
#define EV6_ADAS_RAD_140H_ACC_SPEED_SET_DIS_NAME "ACC_SpeedSetDis"
#define EV6_ADAS_RAD_140H_ACC_TIM_GAP_SET_NAME "ACC_TimGapSet"
#define EV6_ADAS_RAD_140H_ACC_CHECK_SUM_NAME "ACC_CheckSum"
#define EV6_ADAS_RAD_140H_ACC_ROLLING_COUNTER_NAME "ACC_RollingCounter"
#define EV6_ADAS_CAM_10_AH_CAMERA_LKA_WORKING_NAME "Camera_LKAWorking"
#define EV6_ADAS_CAM_10_AH_CAMERA_LDW_STATUS_NAME "Camera_LDWStatus"
#define EV6_ADAS_CAM_10_AH_CAMERA_FAULT_NAME "Camera_Fault"
#define EV6_ADAS_CAM_10_AH_CAMERA_CALIBRATED_STATUS_NAME "Camera_CalibratedStatus"
#define EV6_ADAS_CAM_10_AH_CAMERA_2_L_LANE_STATUS_NAME "Camera_2L_LaneStatus"
#define EV6_ADAS_CAM_10_AH_CAMERA_LDWR_LANE_STATUS_NAME "Camera_LDWRLaneStatus"
#define EV6_ADAS_CAM_10_AH_CAMERA_LDWL_LANE_STATUS_NAME "Camera_LDWLLaneStatus"
#define EV6_ADAS_CAM_10_AH_CAMERA_LKS_STATUS_NAME "Camera_LKSStatus"
#define EV6_ADAS_CAM_10_AH_IHC_STS_NAME "IHCSts"
#define EV6_ADAS_CAM_10_AH_TSR_STS_NAME "TSRSts"
#define EV6_ADAS_CAM_10_AH_CAMERA_HAND_OFF_WARNING_NAME "Camera_HandOffWarning"
#define EV6_ADAS_CAM_10_AH_CAMERA_2_R_LANE_STATUS_NAME "Camera_2R_LaneStatus"
#define EV6_ADAS_CAM_10_AH_CAM_VEHICLE_MONITOR_NAME "CAM_VehicleMonitor"
#define EV6_ADAS_CAM_10_AH_CAM_PEDESTRIAN_MONITOR_NAME "CAM_PedestrianMonitor"
#define EV6_ADAS_CAM_10_AH_ICA_MODE_NAME "ICA_Mode"
#define EV6_ADAS_CAM_10_AH_IHC_FLA_ACTIVE_NAME "IHC_FLA_active"
#define EV6_ADAS_CAM_10_AH_TSR_ATTRIBUTE_NAME "TSR_Attribute"
#define EV6_MCU_97H_MCU_MOT_SPD_VALID_NAME "MCU_MotSpdValid"
#define EV6_MCU_97H_MCU_MOT_TOQ_VALID_NAME "MCU_MotToqValid"
#define EV6_MCU_97H_MCU_MOT_WORKING_STS_NAME "MCU_MotWorkingSts"
#define EV6_MCU_97H_MCU_MOT_ACTU_TOQ_NAME "MCU_MotActuToq"
#define EV6_MCU_97H_MCU_MOT_ACTU_SPD_NAME "MCU_MotActuSpd"
#define EV6_MCU_97H_MCU_10_A_CHECKSUM_NAME "MCU_10A_Checksum"
#define EV6_MCU_97H_MCU_10_A_ROLLING_COUNTER_NAME "MCU_10A_RollingCounter"
#define EV6_ESP_125H_ESP_MASTER_CYLIND_BRAKE_PRESS_NAME "ESP_MasterCylindBrakePress"
#define EV6_ESP_125H_ESP_MASTER_CYLIND_BRAKE_PRESS_VALID_NAME "ESP_MasterCylindBrakePressValid"
#define EV6_ESP_125H_ESP_CHECK_SUM_NAME "ESP_CheckSum"
#define EV6_ESP_125H_ESP_ROLLING_COUNTER_NAME "ESP_RollingCounter"
#define EV6_VCU_119H_VCU_DRIVEN_TRQ_MAX_NAME "VCU_DrivenTrq_MAX"
#define EV6_VCU_119H_VCU_BRK_RECUPERATION_TRQ_MAX_NAME "VCU_BrkRecuperationTrq_MAX"
#define EV6_VCU_119H_VCU_BRK_RECUPERATION_TRQ_CURRENT_NAME "VCU_BrkRecuperationTrq_Current"
#define EV6_VCU_119H_VCU_ROLLING_COUNTER_NAME "VCU_RollingCounter"
#define EV6_VCU_119H_VCU_CHECK_SUM_NAME "VCU_CheckSum"
#define EV6_BCM_105H_HAZARD_STATUS_NAME "HazardStatus"
#define EV6_BCM_105H_RIGHT_TURN_STATUS_NAME "Right_TurnStatus"
#define EV6_BCM_105H_LEFT_TURN_STATUS_NAME "Left_TurnStatus"
#define EV6_BCM_105H_REAR_FOG_STATUS_NAME "Rear_Fog_Status"
#define EV6_BCM_105H_FRONT_FOG_STATUS_NAME "Front_Fog_Status"
#define EV6_BCM_105H_LOW_BEAM_STATUS_NAME "LowBeamStatus"
#define EV6_BCM_105H_HIGH_BEAM_STATUS_NAME "HighBeamStatus"
#define EV6_BCM_105H_REAR_WIPER_STATUS_NAME "RearWiperStatus"
#define EV6_BCM_105H_BRAKE_LAMP_STATUS_NAME "Brake_Lamp_Status"
#define EV6_BCM_105H_FRONT_WIPER_STATUS_NAME "FrontWiperStatus"
#define EV6_BCM_105H_RAINSENSOR_WIPE_REQUEST_NAME "RainsensorWipeRequest"
#define EV6_BCM_105H_IHC_SW_STS_NAME "IHCSwSts"
#define EV6_BCM_105H_LIGHT_VALUE_NAME "LightValue"
#define EV6_ACU_021H_DRV_SEAT_BELT_R_ST_NAME "DrvSeatBeltRSt"
#define EV6_ACU_021H_CRASH_OUTPUT_STS_NAME "CrashOutputSts"
#define EV6_ACU_021H_VCU_CHECK_SUM_NAME "VCU_CheckSum"
#define EV6_ACU_021H_VCU_ROLLING_COUNTER_NAME "VCU_RollingCounter"
#define EV6_VCU_123H_VCU_BRK_PDL_STS_V_NAME "VCU_BrkPdlStsV"
#define EV6_VCU_123H_ACC_MINUS_SET_NAME "ACC_Minus_Set"
#define EV6_VCU_123H_ACC_TIME_GAP_SET_NAME "ACC_TimeGapSet"
#define EV6_VCU_123H_ACC_CANCEL_NAME "ACC_Cancel"
#define EV6_VCU_123H_ACC_MAIN_SWITCH_NAME "ACC_MainSwitch"
#define EV6_VCU_123H_VCU_GASPEDAL_OVERRIDE_NAME "VCU_GaspedalOverride"
#define EV6_VCU_123H_VCU_ACCEL_PDL_POS_V_NAME "VCU_AccelPdlPosV"
#define EV6_VCU_123H_VCU_BRK_PDL_STS_NAME "VCU_BrkPdlSts"
#define EV6_VCU_123H_ACC_PLUS_RESUME_NAME "ACC_Plus_Resume"
#define EV6_VCU_123H_VCU_ACCEL_PDL_POS_NAME "VCU_AccelPdlPos"
#define EV6_VCU_123H_VCU_CHECK_SUM_NAME "VCU_CheckSum"
#define EV6_VCU_123H_VCU_ROLLING_COUNTER_NAME "VCU_RollingCounter"
#define EV6_IBOOSTER_13_CH_BRAKE_PEDAL_APPLIED_NAME "BrakePedalApplied"
#define EV6_IBOOSTER_13_CH_AEB_ACTIVE_NAME "AEBActive"
#define EV6_IBOOSTER_13_CH_EBA_ACTIVE_NAME "EBAActive"
#define EV6_IBOOSTER_13_CH_AWB_ACTIVE_NAME "AWBActive"
#define EV6_IBOOSTER_13_CH_PREFILL_ACTIVE_NAME "PrefillActive"
#define EV6_IBOOSTER_13_CH_IBOOSTER_CONTROL_STATE_NAME "IBOOSTER_Control_State"
#define EV6_IBOOSTER_13_CH_EXT_REQ_STATUS_NAME "ExtReqStatus"
#define EV6_IBOOSTER_13_CH_BRAKE_PEDAL_APPLIED_Q_NAME "BrakePedalApplied_Q"
#define EV6_IBOOSTER_13_CH_IB_CHECK_SUM_NAME "IB_CheckSum"
#define EV6_IBOOSTER_13_CH_IB_ROLING_COUNTER_NAME "IB_RolingCounter"
#define EV6_IBOOSTER_13_AH_S_OUTPUT_ROD_DRIVER_NAME "sOutputRodDriver"
#define EV6_IBOOSTER_13_AH_S_OUTPUT_ROD_DRIVER_Q_NAME "sOutputRodDriver_Q"
#define EV6_IBOOSTER_13_AH_IBOOSTER_CHECK_SUM_NAME "Ibooster_CheckSum"
#define EV6_IBOOSTER_13_AH_IBOOSTER_ROLLING_COUNTER_NAME "Ibooster_RollingCounter"
#define EV6_ADAS_RAD_118H_AEB_AEB_ACTIVE_NAME "AEB_AEBActive"
#define EV6_ADAS_RAD_118H_AEB_EBA_ACTIVE_NAME "AEB_EBAActive"
#define EV6_ADAS_RAD_118H_AEB_AWB_ACTIVE_NAME "AEB_AWBActive"
#define EV6_ADAS_RAD_118H_AEB_FCW_ACTIVE_NAME "AEB_FCWActive"
#define EV6_ADAS_RAD_118H_AEB_PREFILL_ACTIVE_NAME "AEB_PrefillActive"
#define EV6_ADAS_RAD_118H_ACC_ENG_TRQ_REQ_ACTIVE_NAME "ACC_EngTrqReqActive"
#define EV6_ADAS_RAD_118H_ACC_DECEL_REQ_NAME "ACC_Decel_Req"
#define EV6_ADAS_RAD_118H_ACC_DEC_TO_STOP_NAME "ACC_DecToStop"
#define EV6_ADAS_RAD_118H_AEB_AEB_STS_NAME "AEB_AEBSts"
#define EV6_ADAS_RAD_118H_AEB_TARGET_DETECTED_NAME "AEB_TargetDetected"
#define EV6_ADAS_RAD_118H_AEB_AWB_LEVEL_NAME "AEB_AWBLevel"
#define EV6_ADAS_RAD_118H_AEB_AEB_FAILURE_NAME "AEB_AEBFailure"
#define EV6_ADAS_RAD_118H_ACC_DECEL_REQ_VALUE_NAME "ACC_Decel_ReqValue"
#define EV6_ADAS_RAD_118H_ACC_ENG_TRQ_REQ_NAME "ACC_EngTrqReq"
#define EV6_ADAS_RAD_118H_AEB_REQ_DEC_VALUE_NAME "AEB_ReqDecValue"
#define EV6_ADAS_RAD_118H_IB_CHECK_SUM_NAME "IB_CheckSum"
#define EV6_ADAS_RAD_118H_IB_ROLING_COUNTER_NAME "IB_RolingCounter"
#define EV6_APA_92H_APA_VEHICLE_STOP_RQ_NAME "APA_Vehicle_Stop_RQ"
#define EV6_APA_92H_APA_VEHICLE_STOP_RQ_VD_NAME "APA_Vehicle_Stop_RQ_VD"
#define EV6_APA_92H_APA_SYSTEM_STATUS_NAME "APA_System_Status"
#define EV6_APA_92H_APA_2_CHECK_SUM_NAME "APA_2_CheckSum"
#define EV6_APA_92H_APA_2_ROLLING_COUNTER_NAME "APA_2_RollingCounter"
#define EV6_APA_91H_APA_TARGET_ANGLE_NAME "APA_Target_Angle"
#define EV6_APA_91H_APA_STRG_WHL_ANG_SPD_NAME "APA_StrgWhlAngSpd"
#define EV6_APA_91H_APA_EPS_TORQUE_RQ_NAME "APA_EPS_Torque_RQ"
#define EV6_APA_91H_APA_EPS_CONTROL_RQ_NAME "APA_EPS_Control_RQ"
#define EV6_APA_91H_APA_EPS_CONTROL_RQ_VD_NAME "APA_EPS_Control_RQ_VD"
#define EV6_APA_91H_APA_DEGREE_REQ_SIGN_NAME "APA_DegreeReqSign"
#define EV6_APA_91H_APA_1_CHECK_SUM_NAME "APA_1_CheckSum"
#define EV6_APA_91H_APA_1_ROLLING_COUNTER_NAME "APA_1_RollingCounter"
#define EV6_IHU_2_F_CH_TSR_SW_STS_NAME "TSRSwSts"
#define EV6_IHU_2_F_CH_INTELLIGENT_HIGH_BEAM_SW_STS_NAME "IntelligentHighBeamSwSts"
#define EV6_IHU_2_F_CH_LKA_SWITCH_STATUS_NAME "LKASwitchStatus"
#define EV6_IHU_2_F_CH_LDW_SWITCH_STATUS_NAME "LDWSwitchStatus"
#define EV6_IHU_2_F_CH_FCW_AEB_SWITCH_STATUS_NAME "FCW_AEBSwitchStatus"
#define EV6_IHU_2_F_CH_IHU_BSD_SWITCH_STATUS_NAME "IHU_BSDSwitchStatus"
#define EV6_IHU_2_F_CH_IHU_EPS_STEERING_ASSISTANCE_NAME "IHU_EPS_SteeringAssistance"
#define EV6_APA_264H_APA_OBSTACLE_DETECTION_STATUS_NAME "APA_Obstacle_Detection_Status"
#define EV6_VCU_200H_VCU_DRIVE_MODE_NAME "VCU_DriveMode"
#define EV6_VCU_200H_VCU_PT_RDY_NAME "VCU_PtRdy"
#define EV6_VCU_200H_VCU_SHIFT_LEVEL_POSITION_NAME "VCU_ShiftLevelPosition"
#define EV6_VCU_200H_EPB_ACTIVE_NAME "EPBActive"
#define EV6_VCU_200H_VCU_GEAR_CONTROL_MODULE_NAME "VCU_Gear_Control_module"
#define EV6_VCU_200H_VCU_TORQUE_CONTROL_MODULE_NAME "VCU_Torque_Control_module"
#define EV6_VCU_200H_VCU_BRAKE_CONTROL_MODULE_NAME "VCU_Brake_Control_module"
#define EV6_VCU_200H_VCU_CHECK_SUM_NAME "VCU_CheckSum"
#define EV6_VCU_200H_VCU_ROLLING_COUNTER_NAME "VCU_RollingCounter"
#define EV6_EPS_131H_EPS_RESP_APA_WHI_ANG_NAME "EPS_Resp_APA_WhiAng"
#define EV6_EPS_131H_EPS_CAMERA_CTRL_STATUS_NAME "EPS_CameraCtrlStatus"
#define EV6_EPS_131H_EPS_DRIVER_INTERVENTION_STEERING_V_NAME "EPS_DriverInterventionSteeringV"
#define EV6_EPS_131H_EPS_DRIVER_INTERVENTION_STEERING_NAME "EPS_DriverInterventionSteering"
#define EV6_EPS_131H_EPS_TORQUE_V_NAME "EPS_TorqueV"
#define EV6_EPS_131H_EPS_TORQUE_NAME "EPS_Torque"
#define EV6_EPS_131H_EPS_OUTPUT_CURRENT_NAME "EPS_OutputCurrent"
#define EV6_EPS_131H_DRIVER_INPUT_TRQ_VALUE_NAME "DriverInputTrqValue"
#define EV6_EPS_131H_EPS_WORK_MODE_NAME "EPS_WorkMode"
#define EV6_EPS_131H_EPS_CAMERA_ABORT_STATUS_NAME "EPS_CameraAbortStatus"
#define EV6_EPS_131H_HAND_DETECTION_NAME "HandDetection"
#define EV6_EPS_131H_EPS_CHKSM_NAME "EPSChksm"
#define EV6_EPS_131H_EPS_COUNTER_NAME "EPSCounter"
#define EV6_EPS_117H_STRG_WHL_ANG_NAME "StrgWhlAng"
#define EV6_EPS_117H_STRG_WHL_ANG_SPD_NAME "StrgWhlAngSpd"
#define EV6_EPS_117H_EPS_STEERING_ASSISTANCE_NAME "EPSSteeringAssistance"
#define EV6_EPS_117H_EPS_FLR_STS_NAME "EPSFlrSts"
#define EV6_EPS_117H_STRG_WHL_ANG_SNSR_CAL_STS_NAME "StrgWhlAngSnsrCalSts"
#define EV6_EPS_117H_STRG_WHL_ANG_V_NAME "StrgWhlAngV"
#define EV6_EPS_117H_EPS_INHIBIT_CODE_NAME "EPS_INHIBIT_CODE"
#define EV6_EPS_117H_EPS1_CHKSM_NAME "EPS1Chksm"
#define EV6_EPS_117H_EPS1_ROLING_COUNTER_NAME "EPS1RolingCounter"
#define EV6_ESP_109H_LATERAL_ACCE_NAME "LateralAcce"
#define EV6_ESP_109H_LONGIT_ACCE_NAME "LongitAcce"
#define EV6_ESP_109H_YAW_RATE_NAME "YawRate"
#define EV6_ESP_109H_ESP1_CHKSM_NAME "ESP1Chksm"
#define EV6_ESP_109H_ESP1_ROLING_COUNTER_NAME "ESP1RolingCounter"
#define EV6_ADAS_CAM_107H_CAMERA_TORQUE_REQ_NAME "Camera_TorqueReq"
#define EV6_ADAS_CAM_107H_CAMERA_DEGREE_REQ_NAME "Camera_DegreeReq"
#define EV6_ADAS_CAM_107H_CAMERA_DEGREE_REQ_VALID_NAME "Camera_DegreeReqValid"
#define EV6_ADAS_CAM_107H_CAMERA_TORQUE_REQ_VALID_NAME "Camera_TorqueReqValid"
#define EV6_ADAS_CAM_107H_CAMERA_SYS_STATUS_TO_EPS_NAME "Camera_SysStatusToEPS"
#define EV6_ADAS_CAM_107H_CAMERA_DEGREE_SPD_REQ_NAME "Camera_DegreeSpdReq"
#define EV6_ADAS_CAM_107H_CAMERA_CHECK_SUM_NAME "Camera_CheckSum"
#define EV6_ADAS_CAM_107H_CAMERA_ROLING_COUNTER_NAME "Camera_RolingCounter"
#define EV6_ESP_104H_AVH_STS_NAME "AVHSts"
#define EV6_ESP_104H_AVH_AVAILABLE_NAME "AVHAvailable"
#define EV6_ESP_104H_ABS_FAIL_STS_NAME "ABSFailSts"
#define EV6_ESP_104H_ABS_ACTIVE_NAME "ABSActive"
#define EV6_ESP_104H_HDC_AVAILABLE_NAME "HDCAvailable"
#define EV6_ESP_104H_ESP_FUNC_OFF_STS_NAME "ESPFuncOffSts"
#define EV6_ESP_104H_ESP_FAIL_STS_NAME "ESPFailSts"
#define EV6_ESP_104H_EPB_STS_NAME "EPBSts"
#define EV6_ESP_104H_EBD_FAIL_STS_NAME "EBDFailSts"
#define EV6_ESP_104H_EBD_ACTIVE_NAME "EBDActive"
#define EV6_ESP_104H_ESP_ACTIVE_NAME "ESPActive"
#define EV6_ESP_104H_HHC_FAIL_STS_NAME "HHCFailSts"
#define EV6_ESP_104H_HHC_ACTIVE_NAME "HHCActive"
#define EV6_ESP_104H_HDC_STS_NAME "HDCSts"
#define EV6_ESP_104H_VEHICLE_SPD_NAME "VehicleSpd"
#define EV6_ESP_104H_VEHICLE_SPD_VALID_NAME "VehicleSpdValid"
#define EV6_ESP_104H_ESP_CHECK_SUM_NAME "ESP_CheckSum"
#define EV6_ESP_104H_ESP_ROLLING_COUNTER_NAME "ESP_RollingCounter"
#define EV6_ESP_102H_ESC_WHL_FL_SPD_NAME "ESCWhlFLSpd"
#define EV6_ESP_102H_ESC_WHL_FR_SPD_NAME "ESCWhlFRSpd"
#define EV6_ESP_102H_ESC_WHL_RL_SPD_NAME "ESCWhlRLSpd"
#define EV6_ESP_102H_ESC_WHL_RR_SPD_NAME "ESCWhlRRSpd"
#define EV6_ESP_102H_ESP_CHECK_SUM_NAME "ESP_CheckSum"
#define EV6_ESP_102H_ESP_ROLLING_COUNTER_NAME "ESP_RollingCounter"
#define EV6_ESP_101H_RR_WHEEL_DRIVE_DIRECTION_NAME "RRWheelDriveDirection"
#define EV6_ESP_101H_RL_WHEEL_DRIVE_DIRECTION_NAME "RLWheelDriveDirection"
#define EV6_ESP_101H_FR_WHEEL_DRIVE_DIRECTION_NAME "FRWheelDriveDirection"
#define EV6_ESP_101H_FL_WHEEL_DRIVE_DIRECTION_NAME "FLWheelDriveDirection"
#define EV6_ESP_101H_WSS_RR_COUNTS_SUM_VALID_NAME "WssRRCountsSumValid"
#define EV6_ESP_101H_WSS_RL_COUNTS_SUM_VALID_NAME "WssRLCountsSumValid"
#define EV6_ESP_101H_WSS_FR_COUNTS_SUM_VALID_NAME "WssFRCountsSumValid"
#define EV6_ESP_101H_WSS_FL_COUNTS_SUM_VALID_NAME "WssFLCountsSumValid"
#define EV6_ESP_101H_RR_WHEEL_DRIVE_DIRECTION_VALID_NAME "RRWheelDriveDirectionValid"
#define EV6_ESP_101H_RL_WHEEL_DRIVE_DIRECTION_VALID_NAME "RLWheelDriveDirectionValid"
#define EV6_ESP_101H_FR_WHEEL_DRIVE_DIRECTION_VALID_NAME "FRWheelDriveDirectionValid"
#define EV6_ESP_101H_FL_WHEEL_DRIVE_DIRECTION_VALID_NAME "FLWheelDriveDirectionValid"
#define EV6_ESP_101H_WSS_FL_COUNTS_SUM_NAME "WssFLCountsSum"
#define EV6_ESP_101H_WSS_FR_COUNTS_SUM_NAME "WssFRCountsSum"
#define EV6_ESP_101H_WSS_RL_COUNTS_SUM_NAME "WssRLCountsSum"
#define EV6_ESP_101H_WSS_RR_COUNTS_SUM_NAME "WssRRCountsSum"
#define EV6_ESP_101H_ESP_CHECK_SUM_NAME "ESP_CheckSum"
#define EV6_ESP_101H_ESP_ROLLING_COUNTER_NAME "ESP_RollingCounter"

/**
 * Signals in message TBOX_3E3h.
 *
 * All signal values are as on the CAN bus.
 */
struct ev6_tbox_3_e3h_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_213;
};

/**
 * Signals in message TBOX_2FBh.
 *
 * All signal values are as on the CAN bus.
 */
struct ev6_tbox_2_f_bh_t {
    /**
     * µÀÂ·±êÊ¶ÅÆÊ¶±ð¹¦ÄÜ¿ªÆô°´¼ü
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t tbox_tsr_sw_sts;

    /**
     * ÖÇÄÜÔ¶¹âµÆ
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t tbox_intelligent_high_beam_sw_sts;

    /**
     * LKAÑ¡ÔñÉè¶¨¿ª¹Ø
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t tbox_lka_switch_status;

    /**
     * LDWÑ¡ÔñÉè¶¨¿ª¹Ø
     * IHUÉèÖÃ½çÃæ£¬LDW¹¦ÄÜON/OFFÉèÖÃ Èç¹ûÉèÖÃÎªOFF£¬AVMµÄLDW´¦ÓÚ¹Ø±Õ×´Ì¬
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t tbox_ldw_switch_status;

    /**
     * FCW/AEB¹¦ÄÜ¿ª¹Ø×´Ì¬
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t tbox_fcwaeb_switch_status;

    /**
     * ²¢Ïß¸¨Öú¿ª¹Ø
     * IHUÉèÖÃ½çÃæ£¬BSD¹¦ÄÜON/OFFÉèÖÃ Èç¹ûÉèÖÃÎªOFF£¬AVMµÄBSD´¦ÓÚ¹Ø±Õ×´Ì¬
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t tbox_bsd_switch_status;
};

/**
 * Signals in message PEPS_211h.
 *
 * All signal values are as on the CAN bus.
 */
struct ev6_peps_211h_t {
    /**
     * 0x0:OFF
     * 0x1:ONµµ£¬IG1ÓÐÐ§
     * 0x2:Çú±ú¹ÒÆð£¨±¸ÓÃ£©
     * 0x3:Æô¶¯
     * 0x4:Çú±ú¹Ø±Õ£¨±¸ÓÃ£©
     * 0x5~0x7:Ô¤Áô
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t power_mode_peps;
};

/**
 * Signals in message ADAS_RAD_140h.
 *
 * All signal values are as on the CAN bus.
 */
struct ev6_adas_rad_140h_t {
    /**
     * ACC ÇëÇó¼ÝÊ»Ô±½Ó¹Ü³µÁ¾²Ù×÷
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t acc_take_over_req;

    /**
     * ACCµÄÄ£Ê½
     *
     * Range: 0..31 (0..31 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t acc_mod_sts;

    /**
     * Åö×²Ô¤¾¯£¨ÉùÒôÌáÊ¾£©
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t aeb_pre_warning_active;

    /**
     * Åö×²Ô¤¾¯£¨ÎÄ×ÖÌáÊ¾£©
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t aeb_latent_warning_active;

    /**
     * ACC ¸úËæÄ¿±êµÄÓÐÐ§ÐÔ
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t acc_obj_valid;

    /**
     * ACC µÄ¸úËæÄ¿±êÏà¶Ô¾àÀë
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t acc_tar_obj_bar_dis;

    /**
     * ACC³µÁ¾Óë¸úËæÄ¿±êµÄ×ÝÏò¾àÀë
     *
     * Range: 0..254 (0..254 m)
     * Scale: 1
     * Offset: 0
     */
    uint8_t acc_follow_obj_dis;

    /**
     * ACC µÄÉè¶¨Ä¿±ê³µËÙ
     *
     * Range: 0..254 (0..254 Km/h)
     * Scale: 1
     * Offset: 0
     */
    uint8_t acc_speed_set_dis;

    /**
     * ACC µÄÉè¶¨Ê±¾à
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t acc_tim_gap_set;

    /**
     * CheckSum
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t acc_check_sum;

    /**
     * 0-15¼ÆÊý
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t acc_rolling_counter;
};

/**
 * Signals in message ADAS_CAM_10Ah.
 *
 * All signal values are as on the CAN bus.
 */
struct ev6_adas_cam_10_ah_t {
    /**
     * LKA¹¤×÷×´Ì¬
     * ¶¨Òå¸ÃÐÅºÅÎª¡°1¡±Ê±£¬³µµÀÏßÄÚ²àÁÁÆðÁ½¸öÏòÄÚµÄÂÌÉ«¼ýÍ·£¬±íÊ¾³µÁ¾ÕýÔÚ½øÐÐ¾ÓÖÐ±£³Ö¿ØÖÆ
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t camera_lka_working;

    /**
     * LDWµ±Ç°×´Ì¬
     * 0:²»ÏÔÊ¾Í¼±ê
     * £¨²âÊÔLDWÆäËûÐÅºÅ¾ù²»×÷ÏÔÊ¾£©
     * 1:ÏÔÊ¾ÂÌÉ«¹¦ÄÜ¿ªÆôÍ¼Æ¬
     * 2:ÏÔÊ¾ºìÉ«¹¦ÄÜÍ¼±ê£¨Í¬Ê±ICMÐèÒª¸ù¾ÝCamera_StatusºÍCamera_CalibratedStatusÐÅºÅµÄÄÚµÄÐÅÏ¢ÔÚÒÇ±íÅÌÖÐ½øÐÐÎÄ×ÖÌáÊ¾£¬Í¨Öª¼ÝÊ»Ô±¾ßÌåµÄ¹ÊÕÏÐÅÏ¢£©
     * 3:´ý»ú
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t camera_ldw_status;

    /**
     * ÉãÏñÍ·¹ÊÕÏ
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t camera_fault;

    /**
     * ÉãÏñÍ·±ê¶¨×´Ì¬(ÒÇ±íÌáÐÑÏÔÊ¾ÉãÏñÍ·Î´±ê¶¨)
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t camera_calibrated_status;

    /**
     * ×ó²à2³µµÀÏß×´Ì¬
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t camera_2_l_lane_status;

    /**
     * LDWÓÒ²à³µµÀÏß×´Ì¬
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t camera_ldwr_lane_status;

    /**
     * LDW×ó²à³µµÀÏß×´Ì¬
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t camera_ldwl_lane_status;

    /**
     * LKSµ±Ç°×´Ì¬
     * 0:²»ÏÔÊ¾Í¼±ê£¨²âÊÔLDWÆäËûÐÅºÅ¾ù²»×÷ÏÔÊ¾£©
     * 1:ÏÔÊ¾ÂÌÉ«¹¦ÄÜ¿ªÆôÍ¼Æ¬
     * 2:ÏÔÊ¾ºìÉ«¹¦ÄÜÍ¼±ê£¨Í¬Ê±ICMÐèÒª¸ù¾ÝCamera_StatusºÍCamera_CalibratedStatusÐÅºÅµÄÄÚµÄÐÅÏ¢ÔÚÒÇ±íÅÌÖÐ½øÐÐÎÄ×ÖÌáÊ¾£¬Í¨Öª¼ÝÊ»Ô±¾ßÌåµÄ¹ÊÕÏÐÅÏ¢£©
     * 3:´ý»ú
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t camera_lks_status;

    /**
     * ³µ´óµÆ¹¦ÄÜ×´Ì¬
     * 0:ÏÔÊ¾ºìÉ«¹¦ÄÜÍ¼±ê£¨Í¬Ê±ICMÐèÒª¸ù¾ÝCamera_StatusºÍCamera_CalibratedStatusÐÅºÅµÄÄÚµÄÐÅÏ¢ÔÚÒÇ±íÅÌÖÐ½øÐÐÎÄ×ÖÌáÊ¾£¬Í¨Öª¼ÝÊ»Ô±¾ßÌåµÄ¹ÊÕÏÐÅÏ¢£©
     * 1:ÏÔÊ¾ÂÌÉ«Í¼±ê
     * 2:²»ÏÔÊ¾
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ihc_sts;

    /**
     * µÀÂ·±êÊ¶ÅÆÊ¶±ð¹¦ÄÜ×´Ì¬
     * 0:ÏÔÊ¾ºìÉ«¹¦ÄÜÍ¼±ê£¨Í¬Ê±ICMÐèÒª¸ù¾ÝCamera_StatusºÍCamera_CalibratedStatusÐÅºÅµÄÄÚµÄÐÅÏ¢ÔÚÒÇ±íÅÌÖÐ½øÐÐÎÄ×ÖÌáÊ¾£¬Í¨Öª¼ÝÊ»Ô±¾ßÌåµÄ¹ÊÕÏÐÅÏ¢£©
     * 1:ÏÔÊ¾ÂÌÉ«Í¼±ê
     * 2:²»ÏÔÊ¾
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t tsr_sts;

    /**
     * ¼ÝÊ»Ô±ËÉÊÖ±¨¾¯
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t camera_hand_off_warning;

    /**
     * ÓÒ²à2³µµÀÏß×´Ì¬
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t camera_2_r_lane_status;

    /**
     * ³µÁ¾¼à²â
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cam_vehicle_monitor;

    /**
     * ÐÐÈË¼à²â
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cam_pedestrian_monitor;

    /**
     * ICAÄ£Ê½
     * 0:²»ÏÔÊ¾
     * 1:ÏÔÊ¾ÂÌÉ«¹¦ÄÜÍ¼±ê
     * 2ÏÔÊ¾°×É«¹¦ÄÜÍ¼±ê
     * 3:ÏÔÊ¾³ÈÉ«¹¦ÄÜÍ¼±ê
     * 4:ÏÔÊ¾ºìÉ«¹¦ÄÜÍ¼±ê£¨Í¬Ê±ICMÐèÒª¸ù¾ÝCamera_StatusºÍCamera_CalibratedStatusÐÅºÅµÄÄÚµÄÐÅÏ¢ÔÚÒÇ±íÅÌÖÐ½øÐÐÎÄ×ÖÌáÊ¾£¬Í¨Öª¼ÝÊ»Ô±¾ßÌåµÄ¹ÊÕÏÐÅÏ¢£©
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ica_mode;

    /**
     * ³µ´óµÆ¿ª¹ØÇëÇó
     * 0:ÎÞÇëÇó
     * 1:½ü¹âÍ¼±êÁÁ
     * 2:Ô¶¹âµÆÍ¼±êÁÁ
     * 3:Ô¤Áô
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ihc_fla_active;

    /**
     * µÀÂ·±êÊ¶ÅÆÏÞËÙÐÅÏ¢
     *
     * Range: 0..255 (0..255 Km/h)
     * Scale: 1
     * Offset: 0
     */
    uint8_t tsr_attribute;
};

/**
 * Signals in message MCU_97h.
 *
 * All signal values are as on the CAN bus.
 */
struct ev6_mcu_97h_t {
    /**
     * Motor Speed Valid
     * µç»ú×ªËÙÓÐÐ§±êÖ¾Î»
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t mcu_mot_spd_valid;

    /**
     * Motor Torque Valid
     * µç»úÅ¤¾ØÓÐÐ§±êÖ¾Î»
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t mcu_mot_toq_valid;

    /**
     * Motor Working Status
     * µç»ú¹¤×÷×´Ì¬
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t mcu_mot_working_sts;

    /**
     * Motor Actual Torque
     * µç»úµ±Ç°Å¤¾Ø
     *
     * Range: 0..65535 (-2000..4553.5 N*M)
     * Scale: 0.1
     * Offset: -2000
     */
    uint16_t mcu_mot_actu_toq;

    /**
     * Motor Actual Speed
     * µç»úµ±Ç°×ªËÙ
     *
     * Range: 0..65531 (-20000..45531 rpm)
     * Scale: 1
     * Offset: -20000
     */
    uint16_t mcu_mot_actu_spd;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t mcu_10_a_checksum;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t mcu_10_a_rolling_counter;
};

/**
 * Signals in message ESP_125h.
 *
 * All signal values are as on the CAN bus.
 */
struct ev6_esp_125h_t {
    /**
     * ÖÆ¶¯Ö÷¸×Ñ¹Á¦
     * 0x0000-0x0FFE: Valid value
     * 0x0FFF-0xFFFF: Reserved
     *
     * Range: 0..4094 (-100..309.4 Bar)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t esp_master_cylind_brake_press;

    /**
     * ÖÆ¶¯Ö÷¸×Ñ¹Á¦ÓÐÐ§ÐÔ
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t esp_master_cylind_brake_press_valid;

    /**
     * Checksum
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t esp_check_sum;

    /**
     * 0-15¼ÆÊý
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t esp_rolling_counter;
};

/**
 * Signals in message VCU_119h.
 *
 * All signal values are as on the CAN bus.
 */
struct ev6_vcu_119h_t {
    /**
     * VCUµ±Ç°×î´óÇý¶¯Å¤¾Ø
     *
     * Range: 0..65535 (-2000..4553.5 N*M)
     * Scale: 0.1
     * Offset: -2000
     */
    uint16_t vcu_driven_trq_max;

    /**
     * VCU×î´ó»ØÀ¡Å¤¾Ø
     *
     * Range: 0..65535 (-2000..4553.5 N*M)
     * Scale: 0.1
     * Offset: -2000
     */
    uint16_t vcu_brk_recuperation_trq_max;

    /**
     * VCUµ±Ç°»ØÀ¡Å¤¾Ø
     *
     * Range: 0..65535 (-2000..4553.5 N*M)
     * Scale: 0.1
     * Offset: -2000
     */
    uint16_t vcu_brk_recuperation_trq_current;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t vcu_rolling_counter;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t vcu_check_sum;
};

/**
 * Signals in message BCM_105h.
 *
 * All signal values are as on the CAN bus.
 */
struct ev6_bcm_105h_t {
    /**
     * Î£ÏÕ¾¯±¨×´Ì¬
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t hazard_status;

    /**
     * ÓÒ×ªÏòµÆ×´Ì¬
     * 400msÁÁ£¬400msÃðÓÒ×ªÏòµÆ×´Ì¬400msÁÁ£¬400msÃð
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t right_turn_status;

    /**
     * ×ó×ªÏòµÆ×´Ì¬
     * 400msÁÁ£¬400msÃð×ó×ªÏòµÆ×´Ì¬400msÁÁ£¬400msÃð
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t left_turn_status;

    /**
     * ºóÎíµÆ×´Ì¬
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rear_fog_status;

    /**
     * Ç°ÎíµÆ×´Ì¬
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t front_fog_status;

    /**
     * ½ü¹âµÆ×´Ì¬
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t low_beam_status;

    /**
     * Ô¶¹âµÆ×´Ì¬
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t high_beam_status;

    /**
     * ºóÓê¹Î×´Ì¬
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rear_wiper_status;

    /**
     * ÖÆ¶¯µÆ×´Ì¬
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t brake_lamp_status;

    /**
     * Ç°Óê¹Î×´Ì¬£¨Êä³ö£© ÓëÄÚÍâÑ­»·¿ØÖÆÏà¹Ø
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t front_wiper_status;

    /**
     * ¸øADASµÄÓêÁ¿ÐÅºÅ
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rainsensor_wipe_request;

    /**
     * ³µ´óµÆ¹¦ÄÜ¿ªÆô°´¼ü
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ihc_sw_sts;

    /**
     * Ñô¹âÕÕ¶ÈÖµ£¨´óÓÚ10000¾ÍÎªÎÞÐ§Öµ£©0x2711~0xFFFF:Invalid Value
     *
     * Range: 0..10000 (0..10000 lux)
     * Scale: 1
     * Offset: 0
     */
    uint16_t light_value;
};

/**
 * Signals in message ACU_021h.
 *
 * All signal values are as on the CAN bus.
 */
struct ev6_acu_021h_t {
    /**
     * Driver Buckle Switch status
     * ¼ÝÊ»Ô±Ëø¿Û¿ª¹Ø×´Ì¬
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t drv_seat_belt_r_st;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t crash_output_sts;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t vcu_check_sum;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t vcu_rolling_counter;
};

/**
 * Signals in message VCU_123h.
 *
 * All signal values are as on the CAN bus.
 */
struct ev6_vcu_123h_t {
    /**
     * Brake Pedal Status Validity
     * ÖÆ¶¯Ì¤°å×´Ì¬ÓÐÐ§Î»
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t vcu_brk_pdl_sts_v;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t acc_minus_set;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t acc_time_gap_set;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t acc_cancel;

    /**
     * ACC_MainSwitch
     * ACC Ö÷¿ª¹Ø
     * 0:¹Ø±Õµ±Ç°Ñ¡ÖÐµÄ¹¦ÄÜ
     * 1:ACCÄ£Ê½µ±Ç°±»Ñ¡Ôñ
     * 2:ICA/TJAÄ£Ê½±»Ñ¡Ôñ
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t acc_main_switch;

    /**
     * ÅÐ¶ÏACCÊÇ·ñÐèÒª¹ÒÆð
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t vcu_gaspedal_override;

    /**
     * Acceleration pedal PositionValidity
     * ¼ÓËÙÌ¤°åÎ»ÖÃÓÐÐ§Î»
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t vcu_accel_pdl_pos_v;

    /**
     * Brake Pedal Status
     * ÖÆ¶¯Ì¤°å×´Ì¬
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t vcu_brk_pdl_sts;

    /**
     * ACC_Plus_Resume
     * ACC ¼ÓËÙ/·µ»ØÉè¶¨³µËÙ¿ª¹Ø
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t acc_plus_resume;

    /**
     * Acceleration pedal Position
     * ¼ÓËÙÌ¤°åÎ»ÖÃ
     *
     * Range: 0..250 (0..100 -)
     * Scale: 0.4
     * Offset: 0
     */
    uint8_t vcu_accel_pdl_pos;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t vcu_check_sum;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t vcu_rolling_counter;
};

/**
 * Signals in message Ibooster_13Ch.
 *
 * All signal values are as on the CAN bus.
 */
struct ev6_ibooster_13_ch_t {
    /**
     * ÖÆ¶¯Ì¤°å¼¤»î
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t brake_pedal_applied;

    /**
     * AEB¹¦ÄÜ´¥·¢ÇëÇó
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t aeb_active;

    /**
     * EBA¹¦ÄÜ´¥·¢ÇëÇó
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t eba_active;

    /**
     * Åö×²Ô¤¾¯£¨JerkµãÉ²ÌáÊ¾£©
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t awb_active;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t prefill_active;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ibooster_control_state;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ext_req_status;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t brake_pedal_applied_q;

    /**
     * Checksum
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ib_check_sum;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ib_roling_counter;
};

/**
 * Signals in message Ibooster_13Ah.
 *
 * All signal values are as on the CAN bus.
 */
struct ev6_ibooster_13_ah_t {
    /**
     * ¼ÝÊ»Ô±ÊäÈëÍÆ¸ËÐÐ³Ì
     *
     * Range: 0..200 (0..100 %)
     * Scale: 0.5
     * Offset: 0
     */
    uint8_t s_output_rod_driver;

    /**
     * ¼ÝÊ»Ô±ÊäÈëÍÆ¸ËÐÐ³ÌÓÐÐ§Î»
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t s_output_rod_driver_q;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ibooster_check_sum;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ibooster_rolling_counter;
};

/**
 * Signals in message ADAS_RAD_118h.
 *
 * All signal values are as on the CAN bus.
 */
struct ev6_adas_rad_118h_t {
    /**
     * AEB¹¦ÄÜ´¥·¢ÇëÇó
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t aeb_aeb_active;

    /**
     * EBA¹¦ÄÜ´¥·¢ÇëÇó
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t aeb_eba_active;

    /**
     * Åö×²Ô¤¾¯£¨JerkµãÉ²ÌáÊ¾£©
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t aeb_awb_active;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t aeb_fcw_active;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t aeb_prefill_active;

    /**
     * ACCÇý¶¯ÇëÇó
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t acc_eng_trq_req_active;

    /**
     * ACCÖÆ¶¯ÇëÇó£¨ÖÆ¶¯£¬²»Í£Ö¹ÇëÇó£©
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t acc_decel_req;

    /**
     * ACCµÄÖÆ¶¯ÖÁ¾²Ö¹×´Ì¬µÄÇëÇó£¨Í£Ö¹ÇëÇó£©
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t acc_dec_to_stop;

    /**
     * AEB¹¦ÄÜ×´Ì¬
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t aeb_aeb_sts;

    /**
     * AEB¼à²âµ½Ä¿±ê
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t aeb_target_detected;

    /**
     * JerkÔ¤¾¯µãÉ²Á¦¶È£¨µÈ¼¶Ô½¸ß£¬µãÉ²¼õËÙ¶ÈÔ½´ó£©±¸×¢:IboosterÌá¹©level·¶Î§¼´¿É£¬²»ÐèÒª¸ü¸Ä
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t aeb_awb_level;

    /**
     * AEB¹¦ÄÜ¹ÊÕÏ
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t aeb_aeb_failure;

    /**
     * ACCÖÆ¶¯ÇëÇóµÄ¼õËÙ¶ÈÖµ
     *
     * Range: 0..255 (-7..5.75 m/s2)
     * Scale: 0.05
     * Offset: -7
     */
    uint8_t acc_decel_req_value;

    /**
     * ACCÇý¶¯ÇëÇóµÄÅ¤¾ØÖµ
     *
     * Range: 0..65531 (-2000..4553.1 N*m)
     * Scale: 0.1
     * Offset: -2000
     */
    uint16_t acc_eng_trq_req;

    /**
     * AEB/EBAÇëÇóÖÆ¶¯¼õËÙ¶È
     *
     * Range: 0..65535 (-16..15.98108 m/s2)
     * Scale: 0.000488
     * Offset: -16
     */
    uint16_t aeb_req_dec_value;

    /**
     * Checksum
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ib_check_sum;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ib_roling_counter;
};

/**
 * Signals in message APA_92h.
 *
 * All signal values are as on the CAN bus.
 */
struct ev6_apa_92h_t {
    /**
     * PAS³µÁ¾Í£Ö¹ÇëÇó
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t apa_vehicle_stop_rq;

    /**
     * PAS³µÁ¾Í£Ö¹ÇëÇóÓÐÐ§ÐÔ
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t apa_vehicle_stop_rq_vd;

    /**
     * PASÏµÍ³×´Ì¬
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t apa_system_status;

    /**
     * CheckSum
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t apa_2_check_sum;

    /**
     * 0-15¼ÆÊý
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t apa_2_rolling_counter;
};

/**
 * Signals in message APA_91h.
 *
 * All signal values are as on the CAN bus.
 */
struct ev6_apa_91h_t {
    /**
     * PAS_Target_Angle
     * ×ªÏò½Ç¶ÈÖµ
     *
     * Range: 0..14400 (-720..720 deg)
     * Scale: 0.1
     * Offset: -720
     */
    uint16_t apa_target_angle;

    /**
     * Steering Wheel Angle Speed
     * ×ªÏò½ÇËÙ¶È
     *
     * Range: 0..5080 (0..1016 deg/s)
     * Scale: 0.2
     * Offset: 0
     */
    uint16_t apa_strg_whl_ang_spd;

    /**
     * APA·¢ËÍ¸øEPSµÄÅ¤¾ØÇëÇó
     *
     * Range: 0..20000 (-100..100 N*m)
     * Scale: 0.01
     * Offset: -100
     */
    uint16_t apa_eps_torque_rq;

    /**
     * EPS¿ØÖÆÇëÇó
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t apa_eps_control_rq;

    /**
     * EPS¿ØÖÆÇëÇóÓÐÐ§ÐÔ
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t apa_eps_control_rq_vd;

    /**
     * ×ª½ÇÇëÇóÕý¸ºÄæÊ±ÕëÎª¸º£¨×ó×ª£©£¬Ë³Ê±ÕëÎªÕý£¨ÓÒ×ª£©
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t apa_degree_req_sign;

    /**
     * CheckSum
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t apa_1_check_sum;

    /**
     * 0-15¼ÆÊý
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t apa_1_rolling_counter;
};

/**
 * Signals in message IHU_2FCh.
 *
 * All signal values are as on the CAN bus.
 */
struct ev6_ihu_2_f_ch_t {
    /**
     * µÀÂ·±êÊ¶ÅÆÊ¶±ð¹¦ÄÜ¿ªÆô°´¼ü
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t tsr_sw_sts;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t intelligent_high_beam_sw_sts;

    /**
     * LKAÑ¡ÔñÉè¶¨¿ª¹Ø
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t lka_switch_status;

    /**
     * LDWÑ¡ÔñÉè¶¨¿ª¹Ø
     * IHUÉèÖÃ½çÃæ£¬LDW¹¦ÄÜON/OFFÉèÖÃ Èç¹ûÉèÖÃÎªOFF£¬AVMµÄLDW´¦ÓÚ¹Ø±Õ×´Ì¬
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ldw_switch_status;

    /**
     * FCW/AEB¹¦ÄÜ¿ª¹Ø×´Ì¬
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t fcw_aeb_switch_status;

    /**
     * ²¢Ïß¸¨Öú¿ª¹Ø
     * IHUÉèÖÃ½çÃæ£¬BSD¹¦ÄÜON/OFFÉèÖÃ Èç¹ûÉèÖÃÎªOFF£¬AVMµÄBSD´¦ÓÚ¹Ø±Õ×´Ì¬
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ihu_bsd_switch_status;

    /**
     * IHU·¢ËÍ¸øEPSµÄ·½ÏòÅÌ×ªÏòÖúÁ¦µÈ¼¶
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ihu_eps_steering_assistance;
};

/**
 * Signals in message APA_264h.
 *
 * All signal values are as on the CAN bus.
 */
struct ev6_apa_264h_t {
    /**
     * PASÕÏ°­ÎïÕì²â×´Ì¬
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t apa_obstacle_detection_status;
};

/**
 * Signals in message VCU_200h.
 *
 * ¶¯Á¦ÏµÍ³×´Ì¬ Ë²Ê±ÄÜºÄ£¬Ôö¼ÓÅ¤¾Ø¡¢µµÎ»¡¢ÖÆ¶¯¿ØÖÆÇëÇóÀ´Ô´
 *
 * All signal values are as on the CAN bus.
 */
struct ev6_vcu_200h_t {
    /**
     * Vehicle DriveMode
     * ³µÁ¾¼ÝÊ»Ä£Ê½
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t vcu_drive_mode;

    /**
     * Powertrain Ready
     * ¶¯Á¦ÏµÍ³Ready×´Ì¬
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t vcu_pt_rdy;

    /**
     * µµÎ»ÐÅºÅ
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t vcu_shift_level_position;

    /**
     * EPBStatus
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t epb_active;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t vcu_gear_control_module;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t vcu_torque_control_module;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t vcu_brake_control_module;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t vcu_check_sum;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t vcu_rolling_counter;
};

/**
 * Signals in message EPS_131h.
 *
 * All signal values are as on the CAN bus.
 */
struct ev6_eps_131h_t {
    /**
     * EPSÏìÓ¦APA·¢ËÍµÄ½Ç¶ÈÇëÇó
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t eps_resp_apa_whi_ang;

    /**
     * EPS¿ØÖÆ×´Ì¬
     * Mode1:Ô¤Áô
     * Mode2:±ê¶¨²âÊÔÊ¹ÓÃ
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t eps_camera_ctrl_status;

    /**
     * ¼ÝÊ»Ô±Ô¤¸ÉÔ¤ÐÅºÅÓÐÐ§Î»
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t eps_driver_intervention_steering_v;

    /**
     * ¼ÝÊ»Ô±Ô¤¸ÉÔ¤ÐÅºÅ:
     * ADASÔÝ¶¨2N*m  Ê±¼äÎª100ms
     * APAÔÝ¶¨5N*m  Ê±¼äÎª200ms
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t eps_driver_intervention_steering;

    /**
     * EPSÌá¹©µÄ·½ÏòÅÌÅ¤¾ØÓÐÐ§Î»
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t eps_torque_v;

    /**
     * EPS×ÛºÏ´¦ÀíºóÊä³öµÄÅ¤¾Ø
     *
     * Range: 0..20000 (-100..100 N*m)
     * Scale: 0.01
     * Offset: -100
     */
    uint16_t eps_torque;

    /**
     * EPSÊä³öµÄµçÁ÷Öµ
     *
     * Range: 0..255 (0..127.5 A)
     * Scale: 0.5
     * Offset: 0
     */
    uint8_t eps_output_current;

    /**
     * ¼ÝÊ»Ô±ÊäÈëÅ¤¾Ø
     *
     * Range: 0..3000 (-15..15 N*m)
     * Scale: 0.01
     * Offset: -15
     */
    uint16_t driver_input_trq_value;

    /**
     * EPS¹¤×÷Ä£Ê½:
     * 0x0:±ê×¼
     * 0x1:ÊæÊÊ
     * 0x2:ÔË¶¯
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t eps_work_mode;

    /**
     * EPSÖÐÖ¹×´Ì¬Ô­Òò
     * £¨0x1,0x3,0x6,0xAÎªÓÐÐ§ÐÅÏ¢,ÆäËû×´Ì¬ÐÅÏ¢Ô¤Áô£©
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t eps_camera_abort_status;

    /**
     * ÀëÊÖ¼ì²â:
     * 0.5Nm,3-5s¼¤»î
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t hand_detection;

    /**
     * Checksum
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t eps_chksm;

    /**
     * 0-15¼ÆÊý
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t eps_counter;
};

/**
 * Signals in message EPS_117h.
 *
 * All signal values are as on the CAN bus.
 */
struct ev6_eps_117h_t {
    /**
     * Steering Wheel Angle
     * ×ªÏò½Ç¶ÈÖµ(¸ºÖµÎª×ó£¬ÕýÖµÎªÓÒ)
     *
     * Range: 0..14400 (-720..720 deg)
     * Scale: 0.1
     * Offset: -720
     */
    uint16_t strg_whl_ang;

    /**
     * Steering Wheel Angle Speed
     * ×ªÏò½ÇËÙ¶È
     *
     * Range: 0..20320 (-1016..1016 deg/s)
     * Scale: 0.1
     * Offset: -1016
     */
    uint16_t strg_whl_ang_spd;

    /**
     * EPS·´À¡µÄ×ªÏòÖúÁ¦µÈ¼¶
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t eps_steering_assistance;

    /**
     * Electric Power Steering Failure Level
     * EPS¹ÊÕÏµÈ¼¶
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t eps_flr_sts;

    /**
     * Steering Wheel Angle Sensor Calibration Status
     * ×ª½Ç´«¸ÐÆ÷±ê¶¨×´Ì¬
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t strg_whl_ang_snsr_cal_sts;

    /**
     * Steering Wheel Angle Validity
     * ×ªÏò½Ç¶ÈÓÐÐ§Î»
     * £¨EPSÆô¶¯Ê±¼ä¹ý³Ì£¬·¢ËÍµÄÇ°¼¸Ö¡±¨ÎÄÎªÎÞÐ§ÐÅºÅ£¬½ÓÊÕ½ÚµãÐèÅÐ¶ÏÓÐÐ§Î»£©
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t strg_whl_ang_v;

    /**
     * 0x1:OverSpeed
     * 0x2:Driver Interference
     * 0x4:Abnormal CAN Input
     * 0x8:Excess Angle Deviation
     * 0x10:EPS Temporal Failure
     * 0x20:EPS Permanent Faiure
     * 
     * 0x1:³¬ËÙ(ÔÚ¼¤»îÄ£Ê½ÏÂ£¬³µËÙ³¬¹ý10km/h)
     * 0x2:¼ÝÊ»Ô±¸ÉÈÅ(ÔÚ¼¤»îÄ£Ê½ÏÂ£¬¼ÝÊ»Ô±ÊÖ¶¯×ª¶¯·½ÏòÅÌ)
     * 0x4:Òì³£CANÊäÈë(ÈÎºÎÊäÈëÐÅºÅÖµÒì³££¬Èç¶ªÊ§»ò´íÎó¼¤»î¼ÆÊýÆ÷±àºÅ´íÎóÐ£ÑéºÍ£¬»òÈÎºÎÊäÈëÐÅºÅÖµ³¬³öÔÊÐíÖµ)
     * 0x8:¹ý´ó½Ç¶ÈÆ«²î(APA_TGT_ANGLÓëEPS_STEER_ANGL×ªÏò½Ç¶ÈÖ®¼äµÄ½Ç¶È²î³¬¹ý90¶È)
     * 0x10:EPSÔÝÊ±Ê§Ð§(µ¼ÖÂEPSÔÝÊ±ÎÞ·¨ÂÄÐÐÆäÖ°ÔðµÄÌõ¼þ[1].IGN OFFÊÇ¿ÉÑ¡µÄ)
     * 0x20:EPSÓÀ¾ÃÐÔ¹ÊÕÏ(µ¼ÖÂEPSÓÀ¾ÃÎÞ·¨ÂÄÐÐÆäÖ°ÔðµÄÌõ¼þ[2].ÕâÖÖÀàÐÍµÄ¹ÊÕÏÐèÒªIGN OFF)
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t eps_inhibit_code;

    /**
     * CheckSum
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t eps1_chksm;

    /**
     * EPS Roling Counter
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t eps1_roling_counter;
};

/**
 * Signals in message ESP_109h.
 *
 * All signal values are as on the CAN bus.
 */
struct ev6_esp_109h_t {
    /**
     * ºáÏò¼ÓËÙ¶È
     * 0x0000~0xB6A0: Valid value
     * 0xB6A1~0xFFFF: Invalid value
     *
     * Range: 0..46752 (-26.752..20 m/s2)
     * Scale: 0.001
     * Offset: -26.752
     */
    uint16_t lateral_acce;

    /**
     * ×ÝÏò¼ÓËÙ¶È
     * 0x0000~0xB6A0: Valid value
     * 0xB6A1~0xFFFF: Invalid value
     *
     * Range: 0..46752 (-26.752..20 m/s2)
     * Scale: 0.001
     * Offset: -26.752
     */
    uint16_t longit_acce;

    /**
     * ºá°Ú½ÇËÙ¶È
     * 0x0000~0xF80: Valid value
     * 0xF80~0xFFF: Invalid value
     *
     * Range: 0..3968 (-128..120 ¡ã/s)
     * Scale: 0.0625
     * Offset: -128
     */
    uint16_t yaw_rate;

    /**
     * Checksum
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t esp1_chksm;

    /**
     * 0-15¼ÆÊý
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t esp1_roling_counter;
};

/**
 * Signals in message ADAS_CAM_107h.
 *
 * All signal values are as on the CAN bus.
 */
struct ev6_adas_cam_107h_t {
    /**
     * Å¤¾ØÇëÇó´óÐ¡
     *
     * Range: 0..1200 (-6..6 N*m)
     * Scale: 0.01
     * Offset: -6
     */
    uint16_t camera_torque_req;

    /**
     * ×ª½ÇÇëÇó´óÐ¡
     *
     * Range: 0..14400 (-720..720 deg)
     * Scale: 0.1
     * Offset: -720
     */
    uint16_t camera_degree_req;

    /**
     * ½Ç¶ÈÇëÇóÓÐÐ§±êÖ¾
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t camera_degree_req_valid;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t camera_torque_req_valid;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t camera_sys_status_to_eps;

    /**
     * Range: 0..14400 (-720..720 deg/s)
     * Scale: 0.1
     * Offset: -720
     */
    uint16_t camera_degree_spd_req;

    /**
     * Checksum
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t camera_check_sum;

    /**
     * 0-15¼ÆÊý
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t camera_roling_counter;
};

/**
 * Signals in message ESP_104h.
 *
 * All signal values are as on the CAN bus.
 */
struct ev6_esp_104h_t {
    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t avh_sts;

    /**
     * ×Ô¶¯×¤³µÖÆ¶¯
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t avh_available;

    /**
     * ABS¹ÊÕÏ×´Ì¬
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t abs_fail_sts;

    /**
     * ABS¼¤»î£¬ABS¼¤»îºóÄÜÁ¿»ØÀ¡ÍË³ö
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t abs_active;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t hdc_available;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t esp_func_off_sts;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t esp_fail_sts;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t epb_sts;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ebd_fail_sts;

    /**
     * µç×ÓÖÆ¶¯Á¦·ÖÅäÏµÍ³¼¤»î×´Ì¬
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ebd_active;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t esp_active;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t hhc_fail_sts;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t hhc_active;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t hdc_sts;

    /**
     * ³µËÙ
     * 0x0000~0x14D5: Valid
     * 0x14D6~0x1FFE: Reserved
     *
     * Range: 0..5333 (0..300 km/h)
     * Scale: 0.05625
     * Offset: 0
     */
    uint16_t vehicle_spd;

    /**
     * ³µËÙÓÐÐ§Öµ
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t vehicle_spd_valid;

    /**
     * Checksum
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t esp_check_sum;

    /**
     * 0-15¼ÆÊý
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t esp_rolling_counter;
};

/**
 * Signals in message ESP_102h.
 *
 * All signal values are as on the CAN bus.
 */
struct ev6_esp_102h_t {
    /**
     * ESC×óÇ°ÂÖËÙ
     *
     * Range: 0..5333 (0..299.98 Km/h)
     * Scale: 0.05625
     * Offset: 0
     */
    uint16_t esc_whl_fl_spd;

    /**
     * ESCÓÒÇ°ÂÖËÙ
     *
     * Range: 0..5333 (0..299.98 Km/h)
     * Scale: 0.05625
     * Offset: 0
     */
    uint16_t esc_whl_fr_spd;

    /**
     * ESC×óºóÂÖËÙ
     *
     * Range: 0..5333 (0..299.98 Km/h)
     * Scale: 0.05625
     * Offset: 0
     */
    uint16_t esc_whl_rl_spd;

    /**
     * ESCÓÒºóÂÖËÙ
     *
     * Range: 0..5333 (0..299.98 Km/h)
     * Scale: 0.05625
     * Offset: 0
     */
    uint16_t esc_whl_rr_spd;

    /**
     * Checksum
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t esp_check_sum;

    /**
     * 0-15¼ÆÊý
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t esp_rolling_counter;
};

/**
 * Signals in message ESP_101h.
 *
 * All signal values are as on the CAN bus.
 */
struct ev6_esp_101h_t {
    /**
     * ÓÒºóÂÖÇý¶¯·½Ïò
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rr_wheel_drive_direction;

    /**
     * ×óºóÂÖÇý¶¯·½Ïò
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rl_wheel_drive_direction;

    /**
     * ÓÒÇ°ÂÖÇý¶¯·½Ïò
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t fr_wheel_drive_direction;

    /**
     * ×óÇ°ÂÖÇý¶¯·½Ïò
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t fl_wheel_drive_direction;

    /**
     * ÓÒºóÂÖÂö³åÊýÓÐÐ§×´Ì¬Î»
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t wss_rr_counts_sum_valid;

    /**
     * ×óºóÂÖÂö³åÊýÓÐÐ§×´Ì¬Î»
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t wss_rl_counts_sum_valid;

    /**
     * ÓÒÇ°ÂÖÂö³åÊýÓÐÐ§×´Ì¬Î»
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t wss_fr_counts_sum_valid;

    /**
     * ×óÇ°ÂÖÂö³åÊýÓÐÐ§×´Ì¬Î»
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t wss_fl_counts_sum_valid;

    /**
     * ÓÒºóÂÖÇý¶¯·½ÏòÓÐÐ§ÐÔ
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rr_wheel_drive_direction_valid;

    /**
     * ×óºóÂÖÇý¶¯·½ÏòÓÐÐ§ÐÔ
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rl_wheel_drive_direction_valid;

    /**
     * ÓÒÇ°ÂÖÇý¶¯·½ÏòÓÐÐ§ÐÔ
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t fr_wheel_drive_direction_valid;

    /**
     * ×óÇ°ÂÖÇý¶¯·½ÏòÓÐÐ§ÐÔ
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t fl_wheel_drive_direction_valid;

    /**
     * ×óÇ°ÂÖÂö³åÊý
     *
     * Range: 0..255 (0..255 Pluse)
     * Scale: 1
     * Offset: 0
     */
    uint8_t wss_fl_counts_sum;

    /**
     * ÓÒÇ°ÂÖÂö³åÊý
     *
     * Range: 0..255 (0..255 Pluse)
     * Scale: 1
     * Offset: 0
     */
    uint8_t wss_fr_counts_sum;

    /**
     * ×óºóÂÖÂö³åÊý
     *
     * Range: 0..255 (0..255 Pluse)
     * Scale: 1
     * Offset: 0
     */
    uint8_t wss_rl_counts_sum;

    /**
     * ÓÒºóÂÖÂö³åÊý
     *
     * Range: 0..255 (0..255 Pluse)
     * Scale: 1
     * Offset: 0
     */
    uint8_t wss_rr_counts_sum;

    /**
     * Checksum
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t esp_check_sum;

    /**
     * 0-15¼ÆÊý
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t esp_rolling_counter;
};

/**
 * Pack message TBOX_3E3h.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ev6_tbox_3_e3h_pack(
    uint8_t *dst_p,
    const struct ev6_tbox_3_e3h_t *src_p,
    size_t size);

/**
 * Unpack message TBOX_3E3h.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ev6_tbox_3_e3h_unpack(
    struct ev6_tbox_3_e3h_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from TBOX_3E3h.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int ev6_tbox_3_e3h_init(struct ev6_tbox_3_e3h_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_tbox_3_e3h_new_signal_213_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_tbox_3_e3h_new_signal_213_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_tbox_3_e3h_new_signal_213_is_in_range(uint8_t value);

/**
 * Pack message TBOX_2FBh.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ev6_tbox_2_f_bh_pack(
    uint8_t *dst_p,
    const struct ev6_tbox_2_f_bh_t *src_p,
    size_t size);

/**
 * Unpack message TBOX_2FBh.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ev6_tbox_2_f_bh_unpack(
    struct ev6_tbox_2_f_bh_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from TBOX_2FBh.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int ev6_tbox_2_f_bh_init(struct ev6_tbox_2_f_bh_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_tbox_2_f_bh_tbox_tsr_sw_sts_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_tbox_2_f_bh_tbox_tsr_sw_sts_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_tbox_2_f_bh_tbox_tsr_sw_sts_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_tbox_2_f_bh_tbox_intelligent_high_beam_sw_sts_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_tbox_2_f_bh_tbox_intelligent_high_beam_sw_sts_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_tbox_2_f_bh_tbox_intelligent_high_beam_sw_sts_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_tbox_2_f_bh_tbox_lka_switch_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_tbox_2_f_bh_tbox_lka_switch_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_tbox_2_f_bh_tbox_lka_switch_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_tbox_2_f_bh_tbox_ldw_switch_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_tbox_2_f_bh_tbox_ldw_switch_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_tbox_2_f_bh_tbox_ldw_switch_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_tbox_2_f_bh_tbox_fcwaeb_switch_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_tbox_2_f_bh_tbox_fcwaeb_switch_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_tbox_2_f_bh_tbox_fcwaeb_switch_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_tbox_2_f_bh_tbox_bsd_switch_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_tbox_2_f_bh_tbox_bsd_switch_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_tbox_2_f_bh_tbox_bsd_switch_status_is_in_range(uint8_t value);

/**
 * Pack message PEPS_211h.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ev6_peps_211h_pack(
    uint8_t *dst_p,
    const struct ev6_peps_211h_t *src_p,
    size_t size);

/**
 * Unpack message PEPS_211h.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ev6_peps_211h_unpack(
    struct ev6_peps_211h_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from PEPS_211h.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int ev6_peps_211h_init(struct ev6_peps_211h_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_peps_211h_power_mode_peps_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_peps_211h_power_mode_peps_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_peps_211h_power_mode_peps_is_in_range(uint8_t value);

/**
 * Pack message ADAS_RAD_140h.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ev6_adas_rad_140h_pack(
    uint8_t *dst_p,
    const struct ev6_adas_rad_140h_t *src_p,
    size_t size);

/**
 * Unpack message ADAS_RAD_140h.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ev6_adas_rad_140h_unpack(
    struct ev6_adas_rad_140h_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ADAS_RAD_140h.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int ev6_adas_rad_140h_init(struct ev6_adas_rad_140h_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_adas_rad_140h_acc_take_over_req_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_adas_rad_140h_acc_take_over_req_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_adas_rad_140h_acc_take_over_req_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_adas_rad_140h_acc_mod_sts_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_adas_rad_140h_acc_mod_sts_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_adas_rad_140h_acc_mod_sts_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_adas_rad_140h_aeb_pre_warning_active_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_adas_rad_140h_aeb_pre_warning_active_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_adas_rad_140h_aeb_pre_warning_active_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_adas_rad_140h_aeb_latent_warning_active_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_adas_rad_140h_aeb_latent_warning_active_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_adas_rad_140h_aeb_latent_warning_active_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_adas_rad_140h_acc_obj_valid_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_adas_rad_140h_acc_obj_valid_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_adas_rad_140h_acc_obj_valid_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_adas_rad_140h_acc_tar_obj_bar_dis_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_adas_rad_140h_acc_tar_obj_bar_dis_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_adas_rad_140h_acc_tar_obj_bar_dis_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_adas_rad_140h_acc_follow_obj_dis_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_adas_rad_140h_acc_follow_obj_dis_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_adas_rad_140h_acc_follow_obj_dis_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_adas_rad_140h_acc_speed_set_dis_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_adas_rad_140h_acc_speed_set_dis_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_adas_rad_140h_acc_speed_set_dis_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_adas_rad_140h_acc_tim_gap_set_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_adas_rad_140h_acc_tim_gap_set_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_adas_rad_140h_acc_tim_gap_set_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_adas_rad_140h_acc_check_sum_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_adas_rad_140h_acc_check_sum_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_adas_rad_140h_acc_check_sum_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_adas_rad_140h_acc_rolling_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_adas_rad_140h_acc_rolling_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_adas_rad_140h_acc_rolling_counter_is_in_range(uint8_t value);

/**
 * Pack message ADAS_CAM_10Ah.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ev6_adas_cam_10_ah_pack(
    uint8_t *dst_p,
    const struct ev6_adas_cam_10_ah_t *src_p,
    size_t size);

/**
 * Unpack message ADAS_CAM_10Ah.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ev6_adas_cam_10_ah_unpack(
    struct ev6_adas_cam_10_ah_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ADAS_CAM_10Ah.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int ev6_adas_cam_10_ah_init(struct ev6_adas_cam_10_ah_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_adas_cam_10_ah_camera_lka_working_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_adas_cam_10_ah_camera_lka_working_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_adas_cam_10_ah_camera_lka_working_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_adas_cam_10_ah_camera_ldw_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_adas_cam_10_ah_camera_ldw_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_adas_cam_10_ah_camera_ldw_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_adas_cam_10_ah_camera_fault_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_adas_cam_10_ah_camera_fault_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_adas_cam_10_ah_camera_fault_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_adas_cam_10_ah_camera_calibrated_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_adas_cam_10_ah_camera_calibrated_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_adas_cam_10_ah_camera_calibrated_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_adas_cam_10_ah_camera_2_l_lane_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_adas_cam_10_ah_camera_2_l_lane_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_adas_cam_10_ah_camera_2_l_lane_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_adas_cam_10_ah_camera_ldwr_lane_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_adas_cam_10_ah_camera_ldwr_lane_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_adas_cam_10_ah_camera_ldwr_lane_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_adas_cam_10_ah_camera_ldwl_lane_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_adas_cam_10_ah_camera_ldwl_lane_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_adas_cam_10_ah_camera_ldwl_lane_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_adas_cam_10_ah_camera_lks_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_adas_cam_10_ah_camera_lks_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_adas_cam_10_ah_camera_lks_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_adas_cam_10_ah_ihc_sts_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_adas_cam_10_ah_ihc_sts_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_adas_cam_10_ah_ihc_sts_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_adas_cam_10_ah_tsr_sts_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_adas_cam_10_ah_tsr_sts_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_adas_cam_10_ah_tsr_sts_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_adas_cam_10_ah_camera_hand_off_warning_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_adas_cam_10_ah_camera_hand_off_warning_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_adas_cam_10_ah_camera_hand_off_warning_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_adas_cam_10_ah_camera_2_r_lane_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_adas_cam_10_ah_camera_2_r_lane_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_adas_cam_10_ah_camera_2_r_lane_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_adas_cam_10_ah_cam_vehicle_monitor_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_adas_cam_10_ah_cam_vehicle_monitor_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_adas_cam_10_ah_cam_vehicle_monitor_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_adas_cam_10_ah_cam_pedestrian_monitor_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_adas_cam_10_ah_cam_pedestrian_monitor_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_adas_cam_10_ah_cam_pedestrian_monitor_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_adas_cam_10_ah_ica_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_adas_cam_10_ah_ica_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_adas_cam_10_ah_ica_mode_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_adas_cam_10_ah_ihc_fla_active_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_adas_cam_10_ah_ihc_fla_active_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_adas_cam_10_ah_ihc_fla_active_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_adas_cam_10_ah_tsr_attribute_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_adas_cam_10_ah_tsr_attribute_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_adas_cam_10_ah_tsr_attribute_is_in_range(uint8_t value);

/**
 * Pack message MCU_97h.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ev6_mcu_97h_pack(
    uint8_t *dst_p,
    const struct ev6_mcu_97h_t *src_p,
    size_t size);

/**
 * Unpack message MCU_97h.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ev6_mcu_97h_unpack(
    struct ev6_mcu_97h_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from MCU_97h.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int ev6_mcu_97h_init(struct ev6_mcu_97h_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_mcu_97h_mcu_mot_spd_valid_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_mcu_97h_mcu_mot_spd_valid_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_mcu_97h_mcu_mot_spd_valid_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_mcu_97h_mcu_mot_toq_valid_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_mcu_97h_mcu_mot_toq_valid_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_mcu_97h_mcu_mot_toq_valid_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_mcu_97h_mcu_mot_working_sts_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_mcu_97h_mcu_mot_working_sts_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_mcu_97h_mcu_mot_working_sts_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t ev6_mcu_97h_mcu_mot_actu_toq_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_mcu_97h_mcu_mot_actu_toq_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_mcu_97h_mcu_mot_actu_toq_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t ev6_mcu_97h_mcu_mot_actu_spd_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_mcu_97h_mcu_mot_actu_spd_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_mcu_97h_mcu_mot_actu_spd_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_mcu_97h_mcu_10_a_checksum_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_mcu_97h_mcu_10_a_checksum_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_mcu_97h_mcu_10_a_checksum_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_mcu_97h_mcu_10_a_rolling_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_mcu_97h_mcu_10_a_rolling_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_mcu_97h_mcu_10_a_rolling_counter_is_in_range(uint8_t value);

/**
 * Pack message ESP_125h.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ev6_esp_125h_pack(
    uint8_t *dst_p,
    const struct ev6_esp_125h_t *src_p,
    size_t size);

/**
 * Unpack message ESP_125h.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ev6_esp_125h_unpack(
    struct ev6_esp_125h_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ESP_125h.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int ev6_esp_125h_init(struct ev6_esp_125h_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t ev6_esp_125h_esp_master_cylind_brake_press_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_esp_125h_esp_master_cylind_brake_press_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_esp_125h_esp_master_cylind_brake_press_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_esp_125h_esp_master_cylind_brake_press_valid_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_esp_125h_esp_master_cylind_brake_press_valid_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_esp_125h_esp_master_cylind_brake_press_valid_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_esp_125h_esp_check_sum_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_esp_125h_esp_check_sum_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_esp_125h_esp_check_sum_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_esp_125h_esp_rolling_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_esp_125h_esp_rolling_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_esp_125h_esp_rolling_counter_is_in_range(uint8_t value);

/**
 * Pack message VCU_119h.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ev6_vcu_119h_pack(
    uint8_t *dst_p,
    const struct ev6_vcu_119h_t *src_p,
    size_t size);

/**
 * Unpack message VCU_119h.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ev6_vcu_119h_unpack(
    struct ev6_vcu_119h_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from VCU_119h.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int ev6_vcu_119h_init(struct ev6_vcu_119h_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t ev6_vcu_119h_vcu_driven_trq_max_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_vcu_119h_vcu_driven_trq_max_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_vcu_119h_vcu_driven_trq_max_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t ev6_vcu_119h_vcu_brk_recuperation_trq_max_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_vcu_119h_vcu_brk_recuperation_trq_max_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_vcu_119h_vcu_brk_recuperation_trq_max_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t ev6_vcu_119h_vcu_brk_recuperation_trq_current_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_vcu_119h_vcu_brk_recuperation_trq_current_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_vcu_119h_vcu_brk_recuperation_trq_current_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_vcu_119h_vcu_rolling_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_vcu_119h_vcu_rolling_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_vcu_119h_vcu_rolling_counter_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_vcu_119h_vcu_check_sum_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_vcu_119h_vcu_check_sum_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_vcu_119h_vcu_check_sum_is_in_range(uint8_t value);

/**
 * Pack message BCM_105h.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ev6_bcm_105h_pack(
    uint8_t *dst_p,
    const struct ev6_bcm_105h_t *src_p,
    size_t size);

/**
 * Unpack message BCM_105h.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ev6_bcm_105h_unpack(
    struct ev6_bcm_105h_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from BCM_105h.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int ev6_bcm_105h_init(struct ev6_bcm_105h_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_bcm_105h_hazard_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_bcm_105h_hazard_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_bcm_105h_hazard_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_bcm_105h_right_turn_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_bcm_105h_right_turn_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_bcm_105h_right_turn_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_bcm_105h_left_turn_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_bcm_105h_left_turn_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_bcm_105h_left_turn_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_bcm_105h_rear_fog_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_bcm_105h_rear_fog_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_bcm_105h_rear_fog_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_bcm_105h_front_fog_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_bcm_105h_front_fog_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_bcm_105h_front_fog_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_bcm_105h_low_beam_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_bcm_105h_low_beam_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_bcm_105h_low_beam_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_bcm_105h_high_beam_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_bcm_105h_high_beam_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_bcm_105h_high_beam_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_bcm_105h_rear_wiper_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_bcm_105h_rear_wiper_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_bcm_105h_rear_wiper_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_bcm_105h_brake_lamp_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_bcm_105h_brake_lamp_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_bcm_105h_brake_lamp_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_bcm_105h_front_wiper_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_bcm_105h_front_wiper_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_bcm_105h_front_wiper_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_bcm_105h_rainsensor_wipe_request_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_bcm_105h_rainsensor_wipe_request_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_bcm_105h_rainsensor_wipe_request_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_bcm_105h_ihc_sw_sts_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_bcm_105h_ihc_sw_sts_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_bcm_105h_ihc_sw_sts_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t ev6_bcm_105h_light_value_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_bcm_105h_light_value_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_bcm_105h_light_value_is_in_range(uint16_t value);

/**
 * Pack message ACU_021h.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ev6_acu_021h_pack(
    uint8_t *dst_p,
    const struct ev6_acu_021h_t *src_p,
    size_t size);

/**
 * Unpack message ACU_021h.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ev6_acu_021h_unpack(
    struct ev6_acu_021h_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ACU_021h.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int ev6_acu_021h_init(struct ev6_acu_021h_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_acu_021h_drv_seat_belt_r_st_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_acu_021h_drv_seat_belt_r_st_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_acu_021h_drv_seat_belt_r_st_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_acu_021h_crash_output_sts_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_acu_021h_crash_output_sts_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_acu_021h_crash_output_sts_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_acu_021h_vcu_check_sum_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_acu_021h_vcu_check_sum_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_acu_021h_vcu_check_sum_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_acu_021h_vcu_rolling_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_acu_021h_vcu_rolling_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_acu_021h_vcu_rolling_counter_is_in_range(uint8_t value);

/**
 * Pack message VCU_123h.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ev6_vcu_123h_pack(
    uint8_t *dst_p,
    const struct ev6_vcu_123h_t *src_p,
    size_t size);

/**
 * Unpack message VCU_123h.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ev6_vcu_123h_unpack(
    struct ev6_vcu_123h_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from VCU_123h.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int ev6_vcu_123h_init(struct ev6_vcu_123h_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_vcu_123h_vcu_brk_pdl_sts_v_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_vcu_123h_vcu_brk_pdl_sts_v_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_vcu_123h_vcu_brk_pdl_sts_v_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_vcu_123h_acc_minus_set_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_vcu_123h_acc_minus_set_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_vcu_123h_acc_minus_set_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_vcu_123h_acc_time_gap_set_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_vcu_123h_acc_time_gap_set_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_vcu_123h_acc_time_gap_set_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_vcu_123h_acc_cancel_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_vcu_123h_acc_cancel_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_vcu_123h_acc_cancel_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_vcu_123h_acc_main_switch_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_vcu_123h_acc_main_switch_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_vcu_123h_acc_main_switch_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_vcu_123h_vcu_gaspedal_override_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_vcu_123h_vcu_gaspedal_override_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_vcu_123h_vcu_gaspedal_override_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_vcu_123h_vcu_accel_pdl_pos_v_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_vcu_123h_vcu_accel_pdl_pos_v_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_vcu_123h_vcu_accel_pdl_pos_v_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_vcu_123h_vcu_brk_pdl_sts_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_vcu_123h_vcu_brk_pdl_sts_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_vcu_123h_vcu_brk_pdl_sts_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_vcu_123h_acc_plus_resume_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_vcu_123h_acc_plus_resume_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_vcu_123h_acc_plus_resume_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_vcu_123h_vcu_accel_pdl_pos_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_vcu_123h_vcu_accel_pdl_pos_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_vcu_123h_vcu_accel_pdl_pos_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_vcu_123h_vcu_check_sum_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_vcu_123h_vcu_check_sum_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_vcu_123h_vcu_check_sum_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_vcu_123h_vcu_rolling_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_vcu_123h_vcu_rolling_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_vcu_123h_vcu_rolling_counter_is_in_range(uint8_t value);

/**
 * Pack message Ibooster_13Ch.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ev6_ibooster_13_ch_pack(
    uint8_t *dst_p,
    const struct ev6_ibooster_13_ch_t *src_p,
    size_t size);

/**
 * Unpack message Ibooster_13Ch.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ev6_ibooster_13_ch_unpack(
    struct ev6_ibooster_13_ch_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from Ibooster_13Ch.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int ev6_ibooster_13_ch_init(struct ev6_ibooster_13_ch_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_ibooster_13_ch_brake_pedal_applied_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_ibooster_13_ch_brake_pedal_applied_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_ibooster_13_ch_brake_pedal_applied_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_ibooster_13_ch_aeb_active_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_ibooster_13_ch_aeb_active_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_ibooster_13_ch_aeb_active_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_ibooster_13_ch_eba_active_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_ibooster_13_ch_eba_active_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_ibooster_13_ch_eba_active_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_ibooster_13_ch_awb_active_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_ibooster_13_ch_awb_active_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_ibooster_13_ch_awb_active_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_ibooster_13_ch_prefill_active_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_ibooster_13_ch_prefill_active_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_ibooster_13_ch_prefill_active_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_ibooster_13_ch_ibooster_control_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_ibooster_13_ch_ibooster_control_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_ibooster_13_ch_ibooster_control_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_ibooster_13_ch_ext_req_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_ibooster_13_ch_ext_req_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_ibooster_13_ch_ext_req_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_ibooster_13_ch_brake_pedal_applied_q_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_ibooster_13_ch_brake_pedal_applied_q_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_ibooster_13_ch_brake_pedal_applied_q_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_ibooster_13_ch_ib_check_sum_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_ibooster_13_ch_ib_check_sum_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_ibooster_13_ch_ib_check_sum_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_ibooster_13_ch_ib_roling_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_ibooster_13_ch_ib_roling_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_ibooster_13_ch_ib_roling_counter_is_in_range(uint8_t value);

/**
 * Pack message Ibooster_13Ah.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ev6_ibooster_13_ah_pack(
    uint8_t *dst_p,
    const struct ev6_ibooster_13_ah_t *src_p,
    size_t size);

/**
 * Unpack message Ibooster_13Ah.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ev6_ibooster_13_ah_unpack(
    struct ev6_ibooster_13_ah_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from Ibooster_13Ah.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int ev6_ibooster_13_ah_init(struct ev6_ibooster_13_ah_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_ibooster_13_ah_s_output_rod_driver_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_ibooster_13_ah_s_output_rod_driver_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_ibooster_13_ah_s_output_rod_driver_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_ibooster_13_ah_s_output_rod_driver_q_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_ibooster_13_ah_s_output_rod_driver_q_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_ibooster_13_ah_s_output_rod_driver_q_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_ibooster_13_ah_ibooster_check_sum_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_ibooster_13_ah_ibooster_check_sum_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_ibooster_13_ah_ibooster_check_sum_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_ibooster_13_ah_ibooster_rolling_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_ibooster_13_ah_ibooster_rolling_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_ibooster_13_ah_ibooster_rolling_counter_is_in_range(uint8_t value);

/**
 * Pack message ADAS_RAD_118h.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ev6_adas_rad_118h_pack(
    uint8_t *dst_p,
    const struct ev6_adas_rad_118h_t *src_p,
    size_t size);

/**
 * Unpack message ADAS_RAD_118h.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ev6_adas_rad_118h_unpack(
    struct ev6_adas_rad_118h_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ADAS_RAD_118h.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int ev6_adas_rad_118h_init(struct ev6_adas_rad_118h_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_adas_rad_118h_aeb_aeb_active_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_adas_rad_118h_aeb_aeb_active_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_adas_rad_118h_aeb_aeb_active_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_adas_rad_118h_aeb_eba_active_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_adas_rad_118h_aeb_eba_active_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_adas_rad_118h_aeb_eba_active_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_adas_rad_118h_aeb_awb_active_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_adas_rad_118h_aeb_awb_active_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_adas_rad_118h_aeb_awb_active_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_adas_rad_118h_aeb_fcw_active_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_adas_rad_118h_aeb_fcw_active_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_adas_rad_118h_aeb_fcw_active_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_adas_rad_118h_aeb_prefill_active_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_adas_rad_118h_aeb_prefill_active_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_adas_rad_118h_aeb_prefill_active_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_adas_rad_118h_acc_eng_trq_req_active_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_adas_rad_118h_acc_eng_trq_req_active_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_adas_rad_118h_acc_eng_trq_req_active_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_adas_rad_118h_acc_decel_req_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_adas_rad_118h_acc_decel_req_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_adas_rad_118h_acc_decel_req_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_adas_rad_118h_acc_dec_to_stop_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_adas_rad_118h_acc_dec_to_stop_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_adas_rad_118h_acc_dec_to_stop_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_adas_rad_118h_aeb_aeb_sts_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_adas_rad_118h_aeb_aeb_sts_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_adas_rad_118h_aeb_aeb_sts_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_adas_rad_118h_aeb_target_detected_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_adas_rad_118h_aeb_target_detected_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_adas_rad_118h_aeb_target_detected_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_adas_rad_118h_aeb_awb_level_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_adas_rad_118h_aeb_awb_level_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_adas_rad_118h_aeb_awb_level_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_adas_rad_118h_aeb_aeb_failure_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_adas_rad_118h_aeb_aeb_failure_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_adas_rad_118h_aeb_aeb_failure_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_adas_rad_118h_acc_decel_req_value_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_adas_rad_118h_acc_decel_req_value_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_adas_rad_118h_acc_decel_req_value_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t ev6_adas_rad_118h_acc_eng_trq_req_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_adas_rad_118h_acc_eng_trq_req_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_adas_rad_118h_acc_eng_trq_req_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t ev6_adas_rad_118h_aeb_req_dec_value_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_adas_rad_118h_aeb_req_dec_value_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_adas_rad_118h_aeb_req_dec_value_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_adas_rad_118h_ib_check_sum_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_adas_rad_118h_ib_check_sum_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_adas_rad_118h_ib_check_sum_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_adas_rad_118h_ib_roling_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_adas_rad_118h_ib_roling_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_adas_rad_118h_ib_roling_counter_is_in_range(uint8_t value);

/**
 * Pack message APA_92h.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ev6_apa_92h_pack(
    uint8_t *dst_p,
    const struct ev6_apa_92h_t *src_p,
    size_t size);

/**
 * Unpack message APA_92h.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ev6_apa_92h_unpack(
    struct ev6_apa_92h_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from APA_92h.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int ev6_apa_92h_init(struct ev6_apa_92h_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_apa_92h_apa_vehicle_stop_rq_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_apa_92h_apa_vehicle_stop_rq_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_apa_92h_apa_vehicle_stop_rq_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_apa_92h_apa_vehicle_stop_rq_vd_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_apa_92h_apa_vehicle_stop_rq_vd_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_apa_92h_apa_vehicle_stop_rq_vd_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_apa_92h_apa_system_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_apa_92h_apa_system_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_apa_92h_apa_system_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_apa_92h_apa_2_check_sum_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_apa_92h_apa_2_check_sum_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_apa_92h_apa_2_check_sum_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_apa_92h_apa_2_rolling_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_apa_92h_apa_2_rolling_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_apa_92h_apa_2_rolling_counter_is_in_range(uint8_t value);

/**
 * Pack message APA_91h.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ev6_apa_91h_pack(
    uint8_t *dst_p,
    const struct ev6_apa_91h_t *src_p,
    size_t size);

/**
 * Unpack message APA_91h.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ev6_apa_91h_unpack(
    struct ev6_apa_91h_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from APA_91h.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int ev6_apa_91h_init(struct ev6_apa_91h_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t ev6_apa_91h_apa_target_angle_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_apa_91h_apa_target_angle_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_apa_91h_apa_target_angle_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t ev6_apa_91h_apa_strg_whl_ang_spd_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_apa_91h_apa_strg_whl_ang_spd_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_apa_91h_apa_strg_whl_ang_spd_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t ev6_apa_91h_apa_eps_torque_rq_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_apa_91h_apa_eps_torque_rq_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_apa_91h_apa_eps_torque_rq_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_apa_91h_apa_eps_control_rq_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_apa_91h_apa_eps_control_rq_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_apa_91h_apa_eps_control_rq_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_apa_91h_apa_eps_control_rq_vd_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_apa_91h_apa_eps_control_rq_vd_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_apa_91h_apa_eps_control_rq_vd_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_apa_91h_apa_degree_req_sign_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_apa_91h_apa_degree_req_sign_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_apa_91h_apa_degree_req_sign_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_apa_91h_apa_1_check_sum_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_apa_91h_apa_1_check_sum_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_apa_91h_apa_1_check_sum_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_apa_91h_apa_1_rolling_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_apa_91h_apa_1_rolling_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_apa_91h_apa_1_rolling_counter_is_in_range(uint8_t value);

/**
 * Pack message IHU_2FCh.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ev6_ihu_2_f_ch_pack(
    uint8_t *dst_p,
    const struct ev6_ihu_2_f_ch_t *src_p,
    size_t size);

/**
 * Unpack message IHU_2FCh.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ev6_ihu_2_f_ch_unpack(
    struct ev6_ihu_2_f_ch_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from IHU_2FCh.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int ev6_ihu_2_f_ch_init(struct ev6_ihu_2_f_ch_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_ihu_2_f_ch_tsr_sw_sts_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_ihu_2_f_ch_tsr_sw_sts_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_ihu_2_f_ch_tsr_sw_sts_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_ihu_2_f_ch_intelligent_high_beam_sw_sts_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_ihu_2_f_ch_intelligent_high_beam_sw_sts_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_ihu_2_f_ch_intelligent_high_beam_sw_sts_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_ihu_2_f_ch_lka_switch_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_ihu_2_f_ch_lka_switch_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_ihu_2_f_ch_lka_switch_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_ihu_2_f_ch_ldw_switch_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_ihu_2_f_ch_ldw_switch_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_ihu_2_f_ch_ldw_switch_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_ihu_2_f_ch_fcw_aeb_switch_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_ihu_2_f_ch_fcw_aeb_switch_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_ihu_2_f_ch_fcw_aeb_switch_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_ihu_2_f_ch_ihu_bsd_switch_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_ihu_2_f_ch_ihu_bsd_switch_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_ihu_2_f_ch_ihu_bsd_switch_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_ihu_2_f_ch_ihu_eps_steering_assistance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_ihu_2_f_ch_ihu_eps_steering_assistance_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_ihu_2_f_ch_ihu_eps_steering_assistance_is_in_range(uint8_t value);

/**
 * Pack message APA_264h.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ev6_apa_264h_pack(
    uint8_t *dst_p,
    const struct ev6_apa_264h_t *src_p,
    size_t size);

/**
 * Unpack message APA_264h.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ev6_apa_264h_unpack(
    struct ev6_apa_264h_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from APA_264h.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int ev6_apa_264h_init(struct ev6_apa_264h_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_apa_264h_apa_obstacle_detection_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_apa_264h_apa_obstacle_detection_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_apa_264h_apa_obstacle_detection_status_is_in_range(uint8_t value);

/**
 * Pack message VCU_200h.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ev6_vcu_200h_pack(
    uint8_t *dst_p,
    const struct ev6_vcu_200h_t *src_p,
    size_t size);

/**
 * Unpack message VCU_200h.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ev6_vcu_200h_unpack(
    struct ev6_vcu_200h_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from VCU_200h.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int ev6_vcu_200h_init(struct ev6_vcu_200h_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_vcu_200h_vcu_drive_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_vcu_200h_vcu_drive_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_vcu_200h_vcu_drive_mode_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_vcu_200h_vcu_pt_rdy_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_vcu_200h_vcu_pt_rdy_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_vcu_200h_vcu_pt_rdy_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_vcu_200h_vcu_shift_level_position_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_vcu_200h_vcu_shift_level_position_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_vcu_200h_vcu_shift_level_position_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_vcu_200h_epb_active_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_vcu_200h_epb_active_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_vcu_200h_epb_active_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_vcu_200h_vcu_gear_control_module_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_vcu_200h_vcu_gear_control_module_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_vcu_200h_vcu_gear_control_module_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_vcu_200h_vcu_torque_control_module_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_vcu_200h_vcu_torque_control_module_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_vcu_200h_vcu_torque_control_module_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_vcu_200h_vcu_brake_control_module_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_vcu_200h_vcu_brake_control_module_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_vcu_200h_vcu_brake_control_module_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_vcu_200h_vcu_check_sum_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_vcu_200h_vcu_check_sum_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_vcu_200h_vcu_check_sum_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_vcu_200h_vcu_rolling_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_vcu_200h_vcu_rolling_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_vcu_200h_vcu_rolling_counter_is_in_range(uint8_t value);

/**
 * Pack message EPS_131h.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ev6_eps_131h_pack(
    uint8_t *dst_p,
    const struct ev6_eps_131h_t *src_p,
    size_t size);

/**
 * Unpack message EPS_131h.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ev6_eps_131h_unpack(
    struct ev6_eps_131h_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from EPS_131h.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int ev6_eps_131h_init(struct ev6_eps_131h_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_eps_131h_eps_resp_apa_whi_ang_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_eps_131h_eps_resp_apa_whi_ang_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_eps_131h_eps_resp_apa_whi_ang_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_eps_131h_eps_camera_ctrl_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_eps_131h_eps_camera_ctrl_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_eps_131h_eps_camera_ctrl_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_eps_131h_eps_driver_intervention_steering_v_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_eps_131h_eps_driver_intervention_steering_v_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_eps_131h_eps_driver_intervention_steering_v_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_eps_131h_eps_driver_intervention_steering_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_eps_131h_eps_driver_intervention_steering_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_eps_131h_eps_driver_intervention_steering_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_eps_131h_eps_torque_v_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_eps_131h_eps_torque_v_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_eps_131h_eps_torque_v_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t ev6_eps_131h_eps_torque_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_eps_131h_eps_torque_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_eps_131h_eps_torque_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_eps_131h_eps_output_current_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_eps_131h_eps_output_current_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_eps_131h_eps_output_current_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t ev6_eps_131h_driver_input_trq_value_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_eps_131h_driver_input_trq_value_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_eps_131h_driver_input_trq_value_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_eps_131h_eps_work_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_eps_131h_eps_work_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_eps_131h_eps_work_mode_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_eps_131h_eps_camera_abort_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_eps_131h_eps_camera_abort_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_eps_131h_eps_camera_abort_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_eps_131h_hand_detection_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_eps_131h_hand_detection_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_eps_131h_hand_detection_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_eps_131h_eps_chksm_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_eps_131h_eps_chksm_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_eps_131h_eps_chksm_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_eps_131h_eps_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_eps_131h_eps_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_eps_131h_eps_counter_is_in_range(uint8_t value);

/**
 * Pack message EPS_117h.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ev6_eps_117h_pack(
    uint8_t *dst_p,
    const struct ev6_eps_117h_t *src_p,
    size_t size);

/**
 * Unpack message EPS_117h.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ev6_eps_117h_unpack(
    struct ev6_eps_117h_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from EPS_117h.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int ev6_eps_117h_init(struct ev6_eps_117h_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t ev6_eps_117h_strg_whl_ang_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_eps_117h_strg_whl_ang_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_eps_117h_strg_whl_ang_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t ev6_eps_117h_strg_whl_ang_spd_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_eps_117h_strg_whl_ang_spd_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_eps_117h_strg_whl_ang_spd_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_eps_117h_eps_steering_assistance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_eps_117h_eps_steering_assistance_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_eps_117h_eps_steering_assistance_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_eps_117h_eps_flr_sts_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_eps_117h_eps_flr_sts_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_eps_117h_eps_flr_sts_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_eps_117h_strg_whl_ang_snsr_cal_sts_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_eps_117h_strg_whl_ang_snsr_cal_sts_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_eps_117h_strg_whl_ang_snsr_cal_sts_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_eps_117h_strg_whl_ang_v_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_eps_117h_strg_whl_ang_v_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_eps_117h_strg_whl_ang_v_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_eps_117h_eps_inhibit_code_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_eps_117h_eps_inhibit_code_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_eps_117h_eps_inhibit_code_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_eps_117h_eps1_chksm_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_eps_117h_eps1_chksm_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_eps_117h_eps1_chksm_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_eps_117h_eps1_roling_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_eps_117h_eps1_roling_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_eps_117h_eps1_roling_counter_is_in_range(uint8_t value);

/**
 * Pack message ESP_109h.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ev6_esp_109h_pack(
    uint8_t *dst_p,
    const struct ev6_esp_109h_t *src_p,
    size_t size);

/**
 * Unpack message ESP_109h.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ev6_esp_109h_unpack(
    struct ev6_esp_109h_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ESP_109h.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int ev6_esp_109h_init(struct ev6_esp_109h_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t ev6_esp_109h_lateral_acce_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_esp_109h_lateral_acce_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_esp_109h_lateral_acce_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t ev6_esp_109h_longit_acce_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_esp_109h_longit_acce_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_esp_109h_longit_acce_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t ev6_esp_109h_yaw_rate_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_esp_109h_yaw_rate_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_esp_109h_yaw_rate_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_esp_109h_esp1_chksm_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_esp_109h_esp1_chksm_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_esp_109h_esp1_chksm_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_esp_109h_esp1_roling_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_esp_109h_esp1_roling_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_esp_109h_esp1_roling_counter_is_in_range(uint8_t value);

/**
 * Pack message ADAS_CAM_107h.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ev6_adas_cam_107h_pack(
    uint8_t *dst_p,
    const struct ev6_adas_cam_107h_t *src_p,
    size_t size);

/**
 * Unpack message ADAS_CAM_107h.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ev6_adas_cam_107h_unpack(
    struct ev6_adas_cam_107h_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ADAS_CAM_107h.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int ev6_adas_cam_107h_init(struct ev6_adas_cam_107h_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t ev6_adas_cam_107h_camera_torque_req_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_adas_cam_107h_camera_torque_req_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_adas_cam_107h_camera_torque_req_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t ev6_adas_cam_107h_camera_degree_req_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_adas_cam_107h_camera_degree_req_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_adas_cam_107h_camera_degree_req_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_adas_cam_107h_camera_degree_req_valid_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_adas_cam_107h_camera_degree_req_valid_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_adas_cam_107h_camera_degree_req_valid_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_adas_cam_107h_camera_torque_req_valid_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_adas_cam_107h_camera_torque_req_valid_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_adas_cam_107h_camera_torque_req_valid_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_adas_cam_107h_camera_sys_status_to_eps_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_adas_cam_107h_camera_sys_status_to_eps_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_adas_cam_107h_camera_sys_status_to_eps_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t ev6_adas_cam_107h_camera_degree_spd_req_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_adas_cam_107h_camera_degree_spd_req_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_adas_cam_107h_camera_degree_spd_req_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_adas_cam_107h_camera_check_sum_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_adas_cam_107h_camera_check_sum_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_adas_cam_107h_camera_check_sum_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_adas_cam_107h_camera_roling_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_adas_cam_107h_camera_roling_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_adas_cam_107h_camera_roling_counter_is_in_range(uint8_t value);

/**
 * Pack message ESP_104h.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ev6_esp_104h_pack(
    uint8_t *dst_p,
    const struct ev6_esp_104h_t *src_p,
    size_t size);

/**
 * Unpack message ESP_104h.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ev6_esp_104h_unpack(
    struct ev6_esp_104h_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ESP_104h.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int ev6_esp_104h_init(struct ev6_esp_104h_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_esp_104h_avh_sts_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_esp_104h_avh_sts_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_esp_104h_avh_sts_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_esp_104h_avh_available_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_esp_104h_avh_available_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_esp_104h_avh_available_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_esp_104h_abs_fail_sts_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_esp_104h_abs_fail_sts_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_esp_104h_abs_fail_sts_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_esp_104h_abs_active_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_esp_104h_abs_active_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_esp_104h_abs_active_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_esp_104h_hdc_available_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_esp_104h_hdc_available_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_esp_104h_hdc_available_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_esp_104h_esp_func_off_sts_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_esp_104h_esp_func_off_sts_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_esp_104h_esp_func_off_sts_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_esp_104h_esp_fail_sts_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_esp_104h_esp_fail_sts_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_esp_104h_esp_fail_sts_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_esp_104h_epb_sts_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_esp_104h_epb_sts_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_esp_104h_epb_sts_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_esp_104h_ebd_fail_sts_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_esp_104h_ebd_fail_sts_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_esp_104h_ebd_fail_sts_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_esp_104h_ebd_active_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_esp_104h_ebd_active_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_esp_104h_ebd_active_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_esp_104h_esp_active_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_esp_104h_esp_active_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_esp_104h_esp_active_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_esp_104h_hhc_fail_sts_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_esp_104h_hhc_fail_sts_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_esp_104h_hhc_fail_sts_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_esp_104h_hhc_active_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_esp_104h_hhc_active_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_esp_104h_hhc_active_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_esp_104h_hdc_sts_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_esp_104h_hdc_sts_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_esp_104h_hdc_sts_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t ev6_esp_104h_vehicle_spd_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_esp_104h_vehicle_spd_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_esp_104h_vehicle_spd_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_esp_104h_vehicle_spd_valid_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_esp_104h_vehicle_spd_valid_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_esp_104h_vehicle_spd_valid_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_esp_104h_esp_check_sum_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_esp_104h_esp_check_sum_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_esp_104h_esp_check_sum_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_esp_104h_esp_rolling_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_esp_104h_esp_rolling_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_esp_104h_esp_rolling_counter_is_in_range(uint8_t value);

/**
 * Pack message ESP_102h.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ev6_esp_102h_pack(
    uint8_t *dst_p,
    const struct ev6_esp_102h_t *src_p,
    size_t size);

/**
 * Unpack message ESP_102h.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ev6_esp_102h_unpack(
    struct ev6_esp_102h_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ESP_102h.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int ev6_esp_102h_init(struct ev6_esp_102h_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t ev6_esp_102h_esc_whl_fl_spd_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_esp_102h_esc_whl_fl_spd_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_esp_102h_esc_whl_fl_spd_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t ev6_esp_102h_esc_whl_fr_spd_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_esp_102h_esc_whl_fr_spd_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_esp_102h_esc_whl_fr_spd_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t ev6_esp_102h_esc_whl_rl_spd_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_esp_102h_esc_whl_rl_spd_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_esp_102h_esc_whl_rl_spd_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t ev6_esp_102h_esc_whl_rr_spd_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_esp_102h_esc_whl_rr_spd_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_esp_102h_esc_whl_rr_spd_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_esp_102h_esp_check_sum_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_esp_102h_esp_check_sum_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_esp_102h_esp_check_sum_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_esp_102h_esp_rolling_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_esp_102h_esp_rolling_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_esp_102h_esp_rolling_counter_is_in_range(uint8_t value);

/**
 * Pack message ESP_101h.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ev6_esp_101h_pack(
    uint8_t *dst_p,
    const struct ev6_esp_101h_t *src_p,
    size_t size);

/**
 * Unpack message ESP_101h.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ev6_esp_101h_unpack(
    struct ev6_esp_101h_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ESP_101h.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int ev6_esp_101h_init(struct ev6_esp_101h_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_esp_101h_rr_wheel_drive_direction_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_esp_101h_rr_wheel_drive_direction_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_esp_101h_rr_wheel_drive_direction_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_esp_101h_rl_wheel_drive_direction_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_esp_101h_rl_wheel_drive_direction_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_esp_101h_rl_wheel_drive_direction_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_esp_101h_fr_wheel_drive_direction_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_esp_101h_fr_wheel_drive_direction_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_esp_101h_fr_wheel_drive_direction_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_esp_101h_fl_wheel_drive_direction_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_esp_101h_fl_wheel_drive_direction_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_esp_101h_fl_wheel_drive_direction_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_esp_101h_wss_rr_counts_sum_valid_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_esp_101h_wss_rr_counts_sum_valid_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_esp_101h_wss_rr_counts_sum_valid_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_esp_101h_wss_rl_counts_sum_valid_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_esp_101h_wss_rl_counts_sum_valid_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_esp_101h_wss_rl_counts_sum_valid_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_esp_101h_wss_fr_counts_sum_valid_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_esp_101h_wss_fr_counts_sum_valid_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_esp_101h_wss_fr_counts_sum_valid_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_esp_101h_wss_fl_counts_sum_valid_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_esp_101h_wss_fl_counts_sum_valid_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_esp_101h_wss_fl_counts_sum_valid_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_esp_101h_rr_wheel_drive_direction_valid_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_esp_101h_rr_wheel_drive_direction_valid_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_esp_101h_rr_wheel_drive_direction_valid_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_esp_101h_rl_wheel_drive_direction_valid_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_esp_101h_rl_wheel_drive_direction_valid_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_esp_101h_rl_wheel_drive_direction_valid_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_esp_101h_fr_wheel_drive_direction_valid_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_esp_101h_fr_wheel_drive_direction_valid_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_esp_101h_fr_wheel_drive_direction_valid_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_esp_101h_fl_wheel_drive_direction_valid_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_esp_101h_fl_wheel_drive_direction_valid_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_esp_101h_fl_wheel_drive_direction_valid_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_esp_101h_wss_fl_counts_sum_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_esp_101h_wss_fl_counts_sum_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_esp_101h_wss_fl_counts_sum_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_esp_101h_wss_fr_counts_sum_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_esp_101h_wss_fr_counts_sum_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_esp_101h_wss_fr_counts_sum_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_esp_101h_wss_rl_counts_sum_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_esp_101h_wss_rl_counts_sum_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_esp_101h_wss_rl_counts_sum_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_esp_101h_wss_rr_counts_sum_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_esp_101h_wss_rr_counts_sum_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_esp_101h_wss_rr_counts_sum_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_esp_101h_esp_check_sum_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_esp_101h_esp_check_sum_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_esp_101h_esp_check_sum_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ev6_esp_101h_esp_rolling_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ev6_esp_101h_esp_rolling_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ev6_esp_101h_esp_rolling_counter_is_in_range(uint8_t value);


#ifdef __cplusplus
}
#endif

#endif
